<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>GPX Route Planner</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
  <style>
    html, body { height: 100%; margin: 0; display: flex; flex-direction: column;}
    body { margin:0; font-family:sans-serif; }
    h3 { margin: 0; padding: 0.5em; }
    #map { height:calc(100vh - 3em); width: 100%; }
    .command-table { border-collapse: collapse; border: none; font-size: 12px }
    .command-table th, td { border: 1px solid #333; padding: 4px 6px; line-height: 1.2; vertical-align: top; }
    .command-table td:first-child { white-space: nowrap; padding-right: 10px; }
    .header-table { border-collapse: collapse; border: none; width: auto; }
    .header-table td { border: none; padding: 4px 8px; }
    .header-table .title { text-align: left; font-size: 20px; font-weight: bold; white-space: nowrap; }
    .header-table .author { text-align: right; font-size: 12px; font-style: italic; }
	.menu {background: white; padding: 6px 8px; font: 14px/16px Arial, Helvetica, sans-serif; box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
    border-radius: 5px; line-height: 18px; color: #555; }
	.menu i {width: 18px; height: 18px; float: left; margin-right: 8px; opacity: 1.7; }
    .collapsible-menu {cursor: default; }
    .menu-header {cursor: pointer; }
    .solid-popup .leaflet-popup-content-wrapper,
    .solid-popup .leaflet-popup-tip { opacity: 1; }
    .location-item { padding: 8px 10px; border: 1px solid #ccc; border-radius: 4px; background: #ededed; cursor: pointer; user-select: none; transition: background-color 0.2s, border-color 0.2s; }
    .location-item:hover { background: #cacaca; }
    .location-item.selected { background: #b0b0b0; border-color: #3399ff; }
  </style>
</head>
<body>
    <table class="header-table">
    <tr>
    <td class="title">GPX Route Planner</td>
    <td class="author">Developed by Patrick Marie</td>
    </tr>
    </table>
    <div id="map"></div>

    <script src=https://unpkg.com/leaflet@1.9.4/dist/leaflet.js 
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" 
	    crossorigin="">
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
    
    <script type="text/javascript">
    window.onerror = function(message, url, linenumber) {
        if (typeof map !== 'undefined' && map) map.remove();
        const div = document.getElementById("map");
        if (div) div.remove();
        const elemDiv = document.createElement('div');
        elemDiv.innerHTML = `<p>${message}, ligne ${linenumber}</p>`;
        document.body.appendChild(elemDiv);
    }

    //------
    // Main
    //------

    // Custom namespace
    const RP_NS = "https://patrickmarie.dev/ns/routeplanner/extensions";

    // Map
    let map;

    // Colors used to draw the route stages
    let routeColors = { 
        editArrival: '#ff6666',     // Arrival points in edition mode
        editDeparture: '#00cc33',   // Departure points in edition mode
        editRoute: '#2791F5',       // Stage sections in edition mode
        editSingle: '#ff4dff',      // Departure/arrival points in edition mode
        neArrival: '#cc0000',       // Arrival point in non edition mode
        neDeparture: '#008020',     // Departure point in non edition mode 
        neRoute: '#274BF5',         // Stage sections in non edition mode
        neSingle: '#cc00cc'         // Departure/arrival points in non edition mode
    }

    // Weights used to draw the route stages
    let routeWeights = {
        editRoute: 4,   // Stage sections in edit mode
        neRoute: 4      // Stage sections in non edit mode
    }

    // Point sizes used to draw the route
    let markerSize = {
        invisible: 0,   // Invisible point
        small: 5,       // Small size point
        medium: 7,      // Medium size point
        large: 9       // Large size point
    }

    // Route (defined as an array of stages)
    let stages = [];

    // Events registered for the document and for the map
    let documentEvtList = [];
    let docLocFindEvtList = [];
    let mapEvtList = [];
    
    // Context variables
    let context = {
        menuControl: null,            // Control hosting the menu: option selectors and list of commands
        locFinderControl: null,
        geolocControl: null,
        baseMap: null,                  // Base map style
        routerProfile: 'trekking',      // Router profile
        spannedCommand: false,          // Flag: commands spanned or not in the menu
        editedStage: null,              // Currently edited stage
        initializationInProcess: true,  // Flag: initialization in progress
        operationWithButtonInProcess: false,    // Flag: operation such as save, load or set name in process
        clickTimeout: null,             // Timeout used to distinguish simple clicks from double clicks
        suppressNextClick: false,       // Flag used not to take into account next click
        metricUnits: true,              // Flag used to specify whether the metric unit system or the imperial unit system must be used 
        displayInfo: true,              // Flag: info (stage distances and ascents/descents) displayed
        language: 'EN'                  // Language to be used for the UI (English or French)
    };

    // OpenStreetMap tile layer
    const osmTL = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '&copy; OpenStreetMap contributors'
    });

    // OpenTopoMap tile layer
    const otmTL = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
        maxZoom: 15,
        attribution:
            'Map data: &copy; OpenStreetMap contributors, SRTM | ' +
            'Map style: &copy; OpenTopoMap (CC-BY-SA)'
    });

    // Aerial views tile layer
    const esriTL = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
        maxZoom: 19,
        attribution:
            'Tiles &copy; Esri — Source: Esri, Maxar, Earthstar Geographics'
    });

    // Waymarked trails - Hiking
    const wmt_hiking = L.tileLayer('https://tile.waymarkedtrails.org/hiking/{z}/{x}/{y}.png', {
	    maxZoom: 18,
	    attribution: 'Map data: &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors | Map style: &copy; <a href="https://waymarkedtrails.org">waymarkedtrails.org</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'
    });

    // Waymarked trails - Cycling
    const wmt_cycling = L.tileLayer('https://tile.waymarkedtrails.org/cycling/{z}/{x}/{y}.png', {
	    maxZoom: 18,
	    attribution: 'Map data: &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors | Map style: &copy; <a href="https://waymarkedtrails.org">waymarkedtrails.org</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)'
    });

    // Waymarked trails for cyking

    // Base map styles available
    const baseMaps = {
        "OpenTopoMap": otmTL,
        "OpenStreetMap": osmTL,
        "WayMarked Trails - Hiking": wmt_hiking,
        "WayMarked Trails - Cycling": wmt_cycling,
        "Satellite (Esri)": esriTL
    };

    // Router profiles available
    const routerProfilesEn = {
        "Walking / hiking": "trekking",
        "Mountain biking": "mtb",
        "Road cycling": "fastbike",
        "Car route": "car-fast",
        "-- crow --": ""
    };

    const routerProfilesFr = {
        "Marche / randonnée": "trekking",
        "VTT": "mtb",
        "Cyclisme sur route": "fastbike",
        "Automobile": "car-fast",
        "-- vol d\'oiseau --": ""
    };

    // Main block
    try {
        // Create amp
        map = L.map('map', { doubleClickZoom: false }).setView([44.25, 5], 6);

        // Add OpenTopoMap as the default tile layer to the map
        otmTL.addTo(map);

        // Create a specific layer for the markers, so that are always on top of the polylines
        map.createPane('markerPaneTop');
        map.getPane('markerPaneTop').style.zIndex = 650; // Higher than polylines

        // Add a scale bar
        L.control.scale({ imperial: false }).addTo(map);
 
        // Create geolocation control
        setGeolocator();
        
        // Create location finder dialog
        setLocationFinder();
    
        //setEnv4NonEdt();    // Set environment with non edit features
        setEnv4EdtStg(null);    // Start editing a new stage    
    } catch(e) {   
        // Remove map 
        if (typeof map !== 'undefined' && map) { map.remove(); }

        // Remove map division
        const div = document.getElementById("map")
        if (div) {div.remove();}
        
        // Display error message
        const elemDiv = document.createElement('div');
        elemDiv.innerHTML = `<p>${e}</p>`;
        document.body.appendChild(elemDiv);
    }

    //-------------------------------------
    // Set environment for non edit status
    //-------------------------------------
    function setEnv4NonEdt() {
        setMenu4NonEdt();     // Set menu for non edit status

        setDocMap4NonEdt();     // Set document and map event listeners for non edit status

        if (context.editedStage != null)
            setStg4NonEdt(context.editedStage);     // Set layout and event listeners on currently edited stage
    }

    //--------------------------------
    // Set menu for non edit status
    //--------------------------------
    function setMenu4NonEdt() {
        if (context.menuControl) context.menuControl.remove();    // Remove previous menu control

        context.menuControl = L.control({ position: 'topright' });  // Create new menu control

        context.menuControl.onAdd = function (map) {      // Set content into menu control
            // Create white box hosting the menu
            const wrapper = L.DomUtil.create('div', 'leaflet-bar unified-control');
            wrapper.style.background = 'white';
            wrapper.style.padding = '8px';
            wrapper.style.display = 'flex';
            wrapper.style.flexDirection = 'column';
            wrapper.style.gap = '8px';
            wrapper.style.minWidth = '200px';
            wrapper.style.maxWidth = '300px';
            wrapper.style.width = '100%';
            
            // Prevent map interaction
            L.DomEvent.disableClickPropagation(wrapper);
            L.DomEvent.disableScrollPropagation(wrapper);

            // Create title
            const title = L.DomUtil.create('div', 'menu-title', wrapper);
            title.textContent = context.language === 'EN' ? 'Plot your route on the map' : 'Tracez votre itinéraire sur la carte';
            title.style.fontSize = '18px';
            title.style.fontWeight = 'bold';
            title.style.marginBottom = '4px';

            // Create language control
            wrapper.appendChild(createLanguageAndHelpControl(false));

            // Create map style control
            wrapper.appendChild(createMapStyleControl(map));

            // Create router profile control
            wrapper.appendChild(createRouterProfileControl());

            // Create units control
            wrapper.appendChild(createUnitsControl());

            // Create display info control
            wrapper.appendChild(createDisplayInfoControl());

            // Create general buttons control
            wrapper.appendChild(createGenButtonsControl());

            // Create command list for non edit control
            wrapper.appendChild(createCmdListNonEdtControl());

            return wrapper;
        };

        context.menuControl.addTo(map);     // Add menu control to map
    }

    //-----------------------------
    // Create display info control
    //-----------------------------
    function createLanguageAndHelpControl(isTrkEdited) {
        // Create division
        const container = document.createElement('div');
        container.style.display = 'flex';
        container.style.alignItems = 'center';
        container.style.gap = '8px';

        // Create global label
        const globalLabel = document.createElement('span');
        globalLabel.textContent = context.language === 'EN' ? 'Language:' : 'Langue :';
        globalLabel.style.fontSize = '12px';

        // Create radios container
        const radios = document.createElement('div');
        radios.style.display = 'flex';
        radios.style.gap = '6px';
        radios.style.flex = '1';

        // Create English radio button
        const enLabel = document.createElement('label');
        const enRadio = document.createElement('input');
        enRadio.type = 'radio';
        enRadio.name = 'language';
        enRadio.value = 'true';
        enRadio.checked = context.language === 'EN';    // Restore selection

        const enFlag = document.createElement('img');
        enFlag.src = 'https://flagcdn.com/gb.svg';
        enFlag.alt = 'English';
        enFlag.style.width = '24px';
        enFlag.style.height = '18px';
        enFlag.style.objectFit = 'contain';

        const usFlag = document.createElement('img');
        usFlag.src = 'https://flagcdn.com/us.svg';
        usFlag.alt = 'English';
        usFlag.style.width = '24px';
        usFlag.style.height = '18px';
        usFlag.style.objectFit = 'contain';

        enLabel.appendChild(enRadio);
        enLabel.append(enFlag);
        enLabel.append(usFlag);
        enLabel.style.fontSize = '22px';
        enLabel.style.display = 'flex';
        enLabel.style.alignItems = 'center';
        enLabel.style.gap = '6px';

        // Create French radio button
        const frLabel = document.createElement('label');
        const frRadio = document.createElement('input');
        frRadio.type = 'radio';
        frRadio.name = 'language';
        frRadio.value = 'false';
        frRadio.checked = context.language === 'FR';    // Restore selection

        const frFlag = document.createElement('img');
        frFlag.src = 'https://flagcdn.com/fr.svg';
        frFlag.alt = 'Français';
        frFlag.style.width = '24px';
        frFlag.style.height = '18px';
        frFlag.style.objectFit = 'contain';

        frLabel.appendChild(frRadio);
        frLabel.append(frFlag);
        frLabel.style.fontSize = '22px';
        frLabel.style.display = 'flex';
        frLabel.style.alignItems = 'center';
        frLabel.style.gap = '6px';

         // Handle changes
        enRadio.addEventListener('change', () => {
            if (enRadio.checked) {
                context.language = 'EN';

                if (isTrkEdited) setMenu4EdtStg();
                else setMenu4NonEdt();

                setGeolocator();

                setLocationFinder();

                if (context.displayInfo) {
                    for (let i = 0; i < stages.length; i++) {
                        if (context.editedStage === i)
                            updateInfoPopup(stages[i], true);
                        else
                            updateInfoPopup(stages[i], false);

                        showInfoPopup(stages[i]);
                    }
                }
            }
        });

        // Handle changes
        frRadio.addEventListener('change', () => {
            if (frRadio.checked) {
                context.language = 'FR';
                
                if (isTrkEdited) setMenu4EdtStg();
                else setMenu4NonEdt();

                setGeolocator();

                setLocationFinder();

                if (context.displayInfo) {
                    for (let i = 0; i < stages.length; i++) {
                        if (context.editedStage === i)
                            updateInfoPopup(stages[i], true);
                        else
                            updateInfoPopup(stages[i], false);

                        showInfoPopup(stages[i]);
                    }
                }
            }
        });

        // Create help button
        const helpButton = document.createElement('button');
        helpButton.textContent = context.language === 'EN' ? 'Help' : 'Aide';
        helpButton.style.width = '40px';
        helpButton.style.marginLeft = 'auto';

        // Define submit handler (button)
        function helpHandler() {
            const w = window.open('', '_blank');
            w.document.title = context.language === 'EN' ? 'GPX Route Planner – Help' : 'Planificateur d’Itinéraires GPX – Aide';
            w.document.body.innerHTML = context.language === 'EN' ? getHelpContentEn() : getHelpContentFr();
            w.document.close();
        }
        helpButton.addEventListener('click', helpHandler);  // Associate handler with button

        radios.appendChild(enLabel);
        radios.appendChild(frLabel);
        radios.appendChild(helpButton);

        container.appendChild(globalLabel);
        container.appendChild(radios);

        return container;
    }

    //--------------------------
    // Create map style control
    //--------------------------
    function createMapStyleControl(map) {
        // Create division
        const container = L.DomUtil.create('div');
        container.style.display = 'flex';
        container.style.alignItems = 'center';
        container.style.gap = '6px';

        // Create label
        const label = L.DomUtil.create('label', '', container);
        label.textContent = context.language === 'EN' ? 'Map style:' : 'Style de carte :';
        label.style.fontSize = '12px';

        // Create selection box
        const select = L.DomUtil.create('select', '', container);
        Object.keys(baseMaps).forEach(name => {
            const option = document.createElement('option');
            option.value = name;            // stored string
            option.textContent = name;      // displayed label
            select.appendChild(option);
        });

        // Restore selection
        if (context.baseMap && baseMaps[context.baseMap]) {
            select.value = context.baseMap;
        }

        // Handle selection changes
        select.onchange = function () {
            Object.values(baseMaps).forEach(layer => {
                if (map.hasLayer(layer)) map.removeLayer(layer);
            });
            context.baseMap = this.value;
            if (this.value.startsWith("WayMarked Trails"))
                baseMaps["OpenStreetMap"].addTo(map);
            baseMaps[this.value].addTo(map);
        };

        return container;
    }

    //-------------------------------
    // Create router profile control
    //-------------------------------
    function createRouterProfileControl() {
        // Create division
        const container = L.DomUtil.create('div');
        container.style.display = 'flex';
        container.style.alignItems = 'center';
        container.style.gap = '6px';

        // Create label
        const label = L.DomUtil.create('label', '', container);
        label.textContent = context.language === 'EN' ? 'Travel mode:' : 'Mode de voyage :';
        label.style.fontSize = '12px';

        // Create selection box
        const select = L.DomUtil.create('select', '', container);
        Object.entries(context.language === 'EN' ? routerProfilesEn : routerProfilesFr).forEach(([labelText, value]) => {
            const option = document.createElement('option');
            option.value = value;              // stored string
            option.textContent = labelText;    // displayed label
            select.appendChild(option);
        });

        // Default value
        if (context.routerProfile === undefined)
            context.routerProfile = 'trekking';

        // Restore selection
        select.value = context.routerProfile;

        // Handle selection changes
        select.onchange = function () {
            context.routerProfile = this.value; // ✔ string stored
        };

        return container;
    }

    //----------------------
    // Create units control
    //----------------------
    function createUnitsControl() {
        // Create division
        const container = document.createElement('div');
        container.style.display = 'flex';
        container.style.alignItems = 'center';
        container.style.gap = '8px';

        // Create global label
        const globalLabel = document.createElement('span');
        globalLabel.textContent = context.language === 'EN' ? 'Measurement units:' : 'Unités de mesure : ';
        globalLabel.style.fontSize = '12px';

        // Create radios container
        const radios = document.createElement('div');
        radios.style.display = 'flex';
        radios.style.gap = '6px';

        // Create metric radio button
        const metricLabel = document.createElement('label');
        const metricRadio = document.createElement('input');
        metricRadio.type = 'radio';
        metricRadio.name = 'units';
        metricRadio.value = true;
        metricRadio.checked = context.metricUnits === true;    // Restore selection

        metricLabel.appendChild(metricRadio);
        metricLabel.append(context.language === 'EN' ? ' Metric' : ' Métriques');

        // Create imperial radio button
        const imperLabel = document.createElement('label');
        const imperRadio = document.createElement('input');
        imperRadio.type = 'radio';
        imperRadio.name = 'units';
        imperRadio.value = false;
        imperRadio.checked = context.metricUnits === false;    // Restore selection

        imperLabel.appendChild(imperRadio);
        imperLabel.append(context.language === 'EN' ? ' Imperial' : ' Impériales');

         // Handle changes
        metricRadio.addEventListener('change', () => {
            if (metricRadio.checked) {
                context.metricUnits = true;

                if (context.displayInfo) {
                    for (let i = 0; i < stages.length; i++) {
                        if (context.editedStage === i)
                            updateInfoPopup(stages[i], true);
                        else
                            updateInfoPopup(stages[i], false);

                        showInfoPopup(stages[i]);
                    }
                }
            }
        });

        // Handle changes
        imperRadio.addEventListener('change', () => {
            if (imperRadio.checked) {
                context.metricUnits = false;
                
                if (context.displayInfo) {
                    for (let i = 0; i < stages.length; i++) {
                        if (context.editedStage === i)
                            updateInfoPopup(stages[i], true);
                        else
                            updateInfoPopup(stages[i], false);

                        showInfoPopup(stages[i]);
                    }
                }
            }
        });

        radios.appendChild(metricLabel);
        radios.appendChild(imperLabel);

        container.appendChild(globalLabel);
        container.appendChild(radios);

        return container;
    }

    //-----------------------------
    // Create display info control
    //-----------------------------
    function createDisplayInfoControl() {
        // Create division
        const container = document.createElement('div');
        container.style.display = 'flex';
        container.style.alignItems = 'center';
        container.style.gap = '8px';

        // Create global label
        const globalLabel = document.createElement('span');
        globalLabel.textContent = context.language === 'EN' ? 'Display stage information:' : 'Afficher informations sur étapes : ';
        globalLabel.style.fontSize = '12px';

        // Create radios container
        const radios = document.createElement('div');
        radios.style.display = 'flex';
        radios.style.gap = '6px';

        // Create Yes radio button
        const yesLabel = document.createElement('label');
        const yesRadio = document.createElement('input');
        yesRadio.type = 'radio';
        yesRadio.name = 'displayInfo';
        yesRadio.value = true;
        yesRadio.checked = context.displayInfo === true;    // Restore selection

        yesLabel.appendChild(yesRadio);
        yesLabel.append(context.language === 'EN' ? ' Yes' : ' Oui');

        // Create No radio button
        const noLabel = document.createElement('label');
        const noRadio = document.createElement('input');
        noRadio.type = 'radio';
        noRadio.name = 'displayInfo';
        noRadio.value = false;
        noRadio.checked = context.displayInfo === false;    // Restore selection

        noLabel.appendChild(noRadio);
        noLabel.append(context.language === 'EN' ? ' No' : ' Non');

         // Handle changes
        yesRadio.addEventListener('change', () => {
            if (yesRadio.checked) {
                context.displayInfo = true;

                for (let i = 0; i < stages.length; i++) {
                    if (context.editedStage === i)
                        updateInfoPopup(stages[i], true);
                    else
                        updateInfoPopup(stages[i], false);

                    showInfoPopup(stages[i]);
                }
            }
        });

        // Handle changes
        noRadio.addEventListener('change', () => {
            if (noRadio.checked) {
                context.displayInfo = false;
                
                for (let i = 0; i < stages.length; i++)
                    hideInfoPopup(stages[i]);
            }
        });

        radios.appendChild(yesLabel);
        radios.appendChild(noLabel);

        container.appendChild(globalLabel);
        container.appendChild(radios);

        return container;
    }

    //--------------------------------
    // Create general buttons control
    //--------------------------------
    function createGenButtonsControl() {
        // Create division
        const container = document.createElement('div');
        container.style.display = 'flex';
        container.style.alignItems = 'center';
        container.style.gap = '8px';

        // Create global label
        const globalLabel = document.createElement('span');
        globalLabel.textContent = context.language === 'EN' ? 'Global actions:' : 'Actions générales : ';
        globalLabel.style.fontSize = '14px';
        globalLabel.style.fontWeight = 'bold';
        container.appendChild(globalLabel);

        // Create create new stage icon
        const nstIcon = document.createElement('i');
        //nstIcon.classList.add('fa-regular', 'fa-square-plus');
        nstIcon.classList.add('fa-solid', 'fa-arrow-right-to-bracket');
        nstIcon.style.fontSize = '20px';
        nstIcon.style.lineHeight = '20px';
        nstIcon.style.width = '27px';
        nstIcon.style.height = '20px';
        nstIcon.style.display = 'inline-flex';
        nstIcon.style.alignItems = 'center';
        nstIcon.style.justifyContent = 'center';

        // Create button for creating a new stage
        const newStgButton = document.createElement('button');
        newStgButton.appendChild(nstIcon);
        newStgButton.style.width = '35px';
        newStgButton.style.height = '30px';
        newStgButton.title = context.language === 'EN' ? 'Start creating new stage' : 'Démarrer création nouvelle étape';
        container.appendChild(newStgButton);

        // Define submit handler (for creating a new stage)
        async function newStgHandler() {
            setEnv4NonEdt();    // Finish editing the current stage

            setEnv4EdtStg(null);    // Start editing a new stage
        }
        newStgButton.addEventListener('click', newStgHandler);  // Associate submit handler with button
    
        // Create import icon
        const importIcon = document.createElement('i');
        importIcon.classList.add('fa-solid', 'fa-file-import');
        importIcon.style.fontSize = '20px';
        importIcon.style.lineHeight = '20px';
        importIcon.style.width = '27px';
        importIcon.style.height = '20px';
        importIcon.style.display = 'inline-flex';
        importIcon.style.alignItems = 'center';
        importIcon.style.justifyContent = 'center';

        // Create submit button for importing a GPX file
        const importGPXButton = document.createElement('button');
        importGPXButton.appendChild(importIcon);
        importGPXButton.style.width = '35px';
        importGPXButton.style.height = '30px';
        importGPXButton.title = context.language === 'EN' ? 'Import stages from GPX' : 'Importer étapes de GPX';        
        container.appendChild(importGPXButton);

        // Define submit handler (for exporting to a GPX file)
        async function importGPXHandler() {
            importRouteFromGPX();
        }
        importGPXButton.addEventListener('click', importGPXHandler);  // Associate submit handler with button

        // Create export icon
        const exportIcon = document.createElement('i');
        exportIcon.classList.add('fa-solid', 'fa-file-export');
        exportIcon.style.fontSize = '20px';
        exportIcon.style.lineHeight = '20px';
        exportIcon.style.width = '27px';
        exportIcon.style.height = '20px';
        exportIcon.style.display = 'inline-flex';
        exportIcon.style.alignItems = 'center';
        exportIcon.style.justifyContent = 'center';

        // Create submit button for exporting to a GPX file
        const exportGPXButton = document.createElement('button');
        exportGPXButton.appendChild(exportIcon);
        exportGPXButton.style.width = '35px';
        exportGPXButton.style.height = '30px';
        exportGPXButton.title = context.language === 'EN' ? 'Export route to GPX' : 'Exporter l\'itinéraire vers GPX';
        container.appendChild(exportGPXButton);

        // Define submit handler (for exporting to a GPX file)
        async function exportGPXHandler() {
            exportRouteToGPX();
        }
        exportGPXButton.addEventListener('click', exportGPXHandler);  // Associate submit handler with button
    
        // Create reset route icon
        const resetIcon = document.createElement('i');
        resetIcon.classList.add('fa-solid', 'fa-arrow-rotate-left');
        resetIcon.style.fontSize = '20px';
        resetIcon.style.lineHeight = '20px';
        resetIcon.style.width = '27px';
        resetIcon.style.height = '20px';
        resetIcon.style.display = 'inline-flex';
        resetIcon.style.alignItems = 'center';
        resetIcon.style.justifyContent = 'center';

        // Create submit button for resetting the route
        const resetRteButton = document.createElement('button');
        resetRteButton.appendChild(resetIcon);
        resetRteButton.style.width = '35px';
        resetRteButton.style.height = '30px';
        resetRteButton.title = context.language === 'EN' ? 'Reset route' : 'Réinitialiser l\'itinéraire';
        container.appendChild(resetRteButton);

        // Define submit handler (for resetting the route)
        async function resetRteHandler() {
            if (confirm(context.language === 'EN' ? "Are you sure you want to reset the route?" : "Etes-vous sûr de vouloir réinitialiser l'itinéraire ?")) 
                resetRoute();
        }
        resetRteButton.addEventListener('click', resetRteHandler);  // Associate submit handler with button
    
        return container;
    }

    //------------------------------------------
    // Create command list control for non edit
    //------------------------------------------
    function createCmdListNonEdtControl() {
        // Create global container
        const container = L.DomUtil.create('div', 'info menu');
        container.style.maxWidth = '300px';
        container.style.boxSizing = 'border-box';
        container.style.display = 'flex';
        container.style.flexDirection = 'column';

        // Create header iwth span arrow
        const header = L.DomUtil.create('div', 'menu-header', container);
        header.style.cursor = 'pointer';
        header.style.fontSize = '14px';
        header.innerHTML = context.language === 'EN' ? '<strong>Other commands</strong> <span>▼</span>' : '<strong>Autres commandes</strong> <span>▼</span>';
        const arrow = header.querySelector('span');

        // Create command list
        const content = L.DomUtil.create('div', 'menu-content', container);
        content.style.fontSize = '12px';
        content.style.overflowY = context.spannedCommand ? 'auto' : 'hidden'; // scroll when expanded
        content.style.transition = 'max-height 0.3s ease';

        content.innerHTML = context.language === 'EN' ? `
            <br><strong>Global:</strong><br>
            <table class="command-table">
                <tr>
                    <td><strong>Double click on<br>the map</strong></td>
                    <td>Start creating a new stage</td>
                </tr>
                <tr>
                    <td><strong>Double click on<br>a stage</strong></td>
                    <td>Edit the stage</td>
                </tr>
                <tr>
                    <td><strong>e</strong></td>
                    <td>Export the route to a GPX file</td>
                </tr>
                <tr>
                    <td><strong>i</strong></td>
                    <td>Import a route from a GPX file</td>
                </tr>
                <tr>
                    <td><strong>r</strong></td>
                    <td>Reset the current route</td>
                </tr>
            </table>
        ` : `
            <br><strong>Générales :</strong><br><br>
            <table class="command-table">
                <tr>
                    <td><strong>Double cliquer sur<br>la carte</strong></td>
                    <td>Commencer la création<br>d'une nouvelle étape</td>
                </tr>
                <tr>
                    <td><strong>Double cliquer sur<br>une étape</strong></td>
                    <td>Modifier l'étape</td>
                </tr>
                <tr>
                    <td><strong>e</strong></td>
                    <td>Exporter l'itinéraire dans un<br>fichier GPX</td>
                </tr>
                <tr>
                    <td><strong>i</strong></td>
                    <td>Importer un itinéraire d'un<br>fichier GPX</td>
                </tr>
                <tr>
                    <td><strong>r</strong></td>
                    <td>Réinitialiser l'itinéraire<br>en cours</td>
                </tr>
            </table>
        `;

        const isExpanded = context.spannedCommand === true;     // Restore spanned status

        // Adjust max height to content
        if (context.spannedCommand) {
            content.style.maxHeight = '0';       // collapse
            content.style.overflow = 'hidden';

            requestAnimationFrame(() => {
            const mapContainer = map.getContainer(); // Leaflet map container
            const mapHeight = mapContainer.clientHeight;
            const containerRect = container.getBoundingClientRect();
            const availableHeight = mapHeight - containerRect.top - 10; // 10px padding
            content.style.maxHeight = availableHeight + 'px';   // Expand
            content.style.overflowY = 'auto';
            });
        } else {
            content.style.maxHeight = '0';       // Collapse
            content.style.overflow = 'hidden';
        }

        // Select arrow shape
        arrow.textContent = context.spannedCommand ? '▲' : '▼';

        // Handle clicks on the arrow
        L.DomEvent.on(header, 'click', () => {
            context.spannedCommand = !context.spannedCommand;

            // Adjust max height to content
            if (context.spannedCommand) {
                const mapContainer = map.getContainer(); // Leaflet map container
                const mapHeight = mapContainer.clientHeight;
                const containerRect = container.getBoundingClientRect();
                const availableHeight = mapHeight - containerRect.top - 10; // 10px padding

                content.style.maxHeight = availableHeight + 'px';   // Expand
                content.style.overflowY = 'auto';
            } else {
                content.style.maxHeight = '0';       // Collapse
                content.style.overflow = 'hidden';
            }

            arrow.textContent = context.spannedCommand ? '▲' : '▼';
        });

        return container;
    }

    //-----------------------------------------
    // Set document and map to non edit status
    //-----------------------------------------
    function setDocMap4NonEdt() {
        // Delete event listeners on doc for edit status
        for (const { target, type, handler } of documentEvtList)
            target.removeEventListener(type, handler);
        documentEvtList.splice(0);  // Clear registered event listeners

        // Set permanent event listeners (just the first time). They are not registered because they never need to be removed
        if (context.initializationInProcess) {
            // Set permanent event listeners on doc for key pressed (one time for all time)
            function doc_keydown(e) {    
                if (context.operationWithButtonInProcess) return;

                const key = (e.key || '').toLowerCase();

                // If the user is typing in an input or textarea, ignore shortcuts
                const tag = (e.target && e.target.tagName || '').toLowerCase();
                if (tag === 'input' || tag === 'textarea' || e.target.isContentEditable) {
                    return;     // Don't handle t, l, r, s, etc.
                }
            
                if (key === 'e') {   // When user presses 'e' (to save the route to a GPX file)
                    exportRouteToGPX();
                } else if (key === 'i') {   // When user presses 'i' (to load a route from a GPX file)
                    importRouteFromGPX();
                } else if (key === 'z') {   // When user presses 'z' (to reset the route)
                    if (confirm(context.language === 'EN' ? "Are you sure you want to reset the route?" : "Etes-vous sûr de vouloir réinitialiser l'itinéraire ?")) 
                        resetRoute();
                }
            }
            document.addEventListener('keydown', doc_keydown);  // Add event listener to document

            context.initializationInProcess = false;
        }

        map.getContainer().style.cursor = 'grabbing';

        // Delete event listeners on map for edit status
        for (const { target, type, handler } of mapEvtList)
            target.removeEventListener(type, handler);
        mapEvtList.splice(0);

        // Set event listener on map for double-click
        function map_dblclick(e) {
            setEnv4EdtStg(null);    // Start editing a new stage
        }
        map.addEventListener('dblclick', map_dblclick);     // Add listener to map
        mapEvtList.push({ target: map, type: 'dblclick', handler: map_dblclick });    //Register listener
    }

    //------------------------------------------------
    // Set previously edited stage to non edit status
    //------------------------------------------------
    function setStg4NonEdt(i) {
        let stage = null;
        if (i != null)
            stage = stages[i];

        if (stage != null && stage.points.length > 0) {      // When the stage is not empty
            // Process the sections
            for (let j = 0; j < stage.sections.length; j++) {
                const section = stage.sections[j];
                
                section.polyline.setStyle({ color: routeColors.neRoute, weight: routeWeights.neRoute, opacity: 1, fillOpacity: 0 });   // Set layout
        
                // Delete event listeners on section
                for (const { target, type, handler } of section.evtList)
                    target.removeEventListener(type, handler);
                section.evtList.splice(0);

                // Set event listener on section for click (does nothing, but needed to distinguish simple clicks from double-clicks)
                function section_click(e) {
                    if (context.operationWithButtonInProcess) return;   // Not executed if a load or rename operation is in process

                    // Stop a pending single-click
                    if (context.clickTimeout) {
                        clearTimeout(context.clickTimeout);
                        context.clickTimeout = null;
                    }

                    // Execute a timeout of 350 ms, to make sure it is a simple click and not a double click
                    context.clickTimeout = setTimeout(() => {
                        context.clickTimeout = null;
                    }, 350);
                };
                section.polyline.addEventListener('click', section_click);  // Add event listener to the section's polyline
                section.evtList.push({ target: section.polyline, type: 'click', handler: section_click });      // Register event listener

                // Set event listener on section for double-click
                const section_dblclick = (function(stageRef) {
                    return function(e) {
                        if (context.operationWithButtonInProcess) return;   // Not executed if a load or rename operation is in process

                        // Retrieve stage number
                        const iRef = stages.indexOf(stageRef);
                        if (iRef === -1)
                            return;     // Stage was removed; do nothing

                        // Stop a pending single-click
                        if (context.clickTimeout) {
                            clearTimeout(context.clickTimeout);
                            context.clickTimeout = null;
                        }
    
                        L.DomEvent.stopPropagation(e);  // Do not propagate event to map and document
        
                        quitEditStage();    // If another stage was being edited, set it to non edit status

                        setEnv4EdtStg(iRef);    // Set the double clicked stage to edit status
                    };   
                })(stage);
                section.polyline.addEventListener('dblclick', section_dblclick);  // Add event listener to the section's polyline
                section.evtList.push({ target: section.polyline, type: 'dblclick', handler: section_dblclick });    // Register event listener
            };

            // Process the points
            for (let j = 0; j < stage.points.length; j++) {
                const point = stage.points[j];

                // Set point layout
                if (j === 0 && stage.points.length === 1)
                    point.marker.setStyle({ radius: markerSize.medium, opacity: 1, fillOpacity: 0, color: routeColors.neSingle });
                else if (j === 0)
                    point.marker.setStyle({ radius: markerSize.medium, opacity: 1, fillOpacity: 0, color: routeColors.neDeparture });
                else if (j < stages[i].points.length - 1)
                    point.marker.setStyle({ radius: markerSize.invisible, opacity: 0, fillOpacity: 0 });
                else
                    point.marker.setStyle({ radius: markerSize.large, opacity: 1, fillOpacity: 0, color: routeColors.neArrival });        

                // Delete event listeners on point
                for (const { target, type, handler } of point.evtList)
                    target.removeEventListener(type, handler);
                point.evtList.splice(0);

                // Set event listener on point for click
                function point_click(e) {
                    if (context.operationWithButtonInProcess) return;   // Not executed if a load or rename operation is in process

                    // Stop a pending single-click
                    if (context.clickTimeout) {
                        clearTimeout(context.clickTimeout);
                        context.clickTimeout = null;
                    }

                    // Execute a timeout of 350 ms, to make sure it is a simple click and not a double click
                    context.clickTimeout = setTimeout(() => {
                        context.clickTimeout = null;
                    }, 350);
                };
                point.marker.addEventListener('click', point_click);
                point.evtList.push({ target: point.marker, type: 'click', handler: point_click });    

                // Set event listener on point for double-click
                const point_dblclick = (function(stageRef) {
                    return function (e) {
                        const iRef = stages.indexOf(stageRef);
                        if (iRef === -1) return;     // Stage was removed; do nothing

                        if (context.operationWithButtonInProcess) return;

                        // Stop the pending single-click
                        if (context.clickTimeout) {
                            clearTimeout(context.clickTimeout);
                            context.clickTimeout = null;
                        }
    
                        L.DomEvent.stopPropagation(e);  // Do not propagate event to map and document
        
                        quitEditStage();

                        setEnv4EdtStg(iRef);
                    }
                })(stage);
                point.marker.addEventListener('dblclick', point_dblclick);  // Add event listener to the section's marker
                point.evtList.push({ target: point.marker, type: 'dblclick', handler: point_dblclick });    // Register event listener
            }
            
            // Update stage information to be displayed in popup and show it (if selected)
            updateInfoPopup(stages[i], false);
            if (context.displayInfo) {
                showInfoPopup(stages[i]);
            }
        } else if (stage != null) {
            deleteStg(i);   // If the stage is empty, delete it
        }

        context.editedStage = null;     // Register that there is no more stage being edited
    }

    //---------------------------------------
    // Set environment for edit stage status
    //---------------------------------------
    function setEnv4EdtStg(i) {
        setMenu4EdtStg();     // Set menu for edit stage status

        // Add new empty stage to the route if arg is null
        if (i === null) {
            i = createNewEmptyStage();
        }

        setDocMap4EdtStg(i);    // Set document and map for edit stage status

        setStg4EdtStg(i);   // Set stage to be edited for edit status
    }

    //----------------------------------
    // Set menu fpr edit stage status
    //----------------------------------
    function setMenu4EdtStg() {
        if (context.menuControl) context.menuControl.remove();      // Remove previous menu control

        context.menuControl = L.control({ position: 'topright' });    // Create new menu control

        context.menuControl.onAdd = function (map) {          // Set content into menu control     
            // Create white box hosting the menu
            const wrapper = L.DomUtil.create('div', 'leaflet-bar unified-control');
            wrapper.style.background = 'white';
            wrapper.style.padding = '8px';
            wrapper.style.display = 'flex';
            wrapper.style.flexDirection = 'column';
            wrapper.style.gap = '8px';
            wrapper.style.minWidth = '200px';
            wrapper.style.maxWidth = '310px';
            wrapper.style.width = '100%';

            // Prevent map interaction
            L.DomEvent.disableClickPropagation(wrapper);
            L.DomEvent.disableScrollPropagation(wrapper);

            // Create title
            const title = L.DomUtil.create('div', 'menu-title', wrapper);
            title.textContent = context.language === 'EN' ? 'Plot your route on the map' : 'Tracez votre itinéraire sur la carte';
            title.style.fontSize = '18px';
            title.style.fontWeight = 'bold';
            title.style.marginBottom = '4px';

            // Create language control
            wrapper.appendChild(createLanguageAndHelpControl(true));

            // Create map style contol
            wrapper.appendChild(createMapStyleControl(map));

            // Create router profile control
            wrapper.appendChild(createRouterProfileControl());

            // Create units control
            wrapper.appendChild(createUnitsControl());

            // Create display info control
            wrapper.appendChild(createDisplayInfoControl());

            // Create edit stage buttons control
            const edtStgButtonsContainers = createEdtStgButtonsControl();
            wrapper.appendChild(edtStgButtonsContainers[0]);
            wrapper.appendChild(edtStgButtonsContainers[1]);

            // Create general buttons control
            wrapper.appendChild(createGenButtonsControl());

            // Create command list for edit stage control
            wrapper.appendChild(createCmdListEdtStgControl());

            return wrapper;
        };

        context.menuControl.addTo(map);
    }

    //--------------------------------
    // Create edit stage buttons control
    //--------------------------------
    function createEdtStgButtonsControl() {
        // Create title division
        const titleContainer = document.createElement('div');
        titleContainer.style.display = 'flex';
        titleContainer.style.alignItems = 'center';
        titleContainer.style.gap = '8px';

        // Create global label
        const globalLabel = document.createElement('span');
        globalLabel.textContent = context.language === 'EN' ? 'Edit stage actions:' : 'Actions édition d\'étape : ';
        globalLabel.style.fontSize = '14px';
        globalLabel.style.fontWeight = 'bold';
        titleContainer.appendChild(globalLabel);

        // Create buttons division
        const buttonsContainer = document.createElement('div');
        buttonsContainer.style.display = 'flex';
        buttonsContainer.style.alignItems = 'center';
        buttonsContainer.style.gap = '8px';

        // Create set name icon
        const snIcon = document.createElement('i');
        snIcon.classList.add('fa-solid', 'fa-n');
        snIcon.style.fontSize = '20px';
        snIcon.style.lineHeight = '20px';
        snIcon.style.width = '27px';
        snIcon.style.height = '20px';
        snIcon.style.display = 'inline-flex';
        snIcon.style.alignItems = 'center';
        snIcon.style.justifyContent = 'center';

        // Create submit button for setting the stage's name
        const setNameButton = document.createElement('button');
        setNameButton.appendChild(snIcon);
        setNameButton.style.width = '35px';
        setNameButton.style.height = '30px';
        setNameButton.title = context.language === 'EN' ? 'Set stage name' : 'Attribuer nom à l\'étape';
        buttonsContainer.appendChild(setNameButton);

        // Define submit handler (for setting the stage's name)
        async function setNameHandler() {
            setStgName();
        }
        setNameButton.addEventListener('click', setNameHandler);  // Associate submit handler with button
    
        // Create reverse stage direction icon
        const rsIcon = document.createElement('i');
        rsIcon.classList.add('fa-solid', 'fa-arrow-right-arrow-left');
        rsIcon.style.fontSize = '20px';
        rsIcon.style.lineHeight = '20px';
        rsIcon.style.width = '27px';
        rsIcon.style.height = '20px';
        rsIcon.style.display = 'inline-flex';
        rsIcon.style.alignItems = 'center';
        rsIcon.style.justifyContent = 'center';

        // Create submit button for reverse stage direction
        const revStgButton = document.createElement('button');
        revStgButton.appendChild(rsIcon);
        revStgButton.style.width = '35px';
        revStgButton.style.height = '30px';
        revStgButton.title = context.language === 'EN' ? 'Reverse stage direction' : 'Inverser direction de l\'étape';
        buttonsContainer.appendChild(revStgButton);

        // Define submit handler (for reverse stage direction)
        async function revStgHandler() {
            reverseStage();
        }
        revStgButton.addEventListener('click', revStgHandler);  // Associate submit handler with button
       
        // Create split stage icon
        const splitIcon = document.createElement('i');
        splitIcon.classList.add('fa-solid', 'fa-scissors');
        splitIcon.style.fontSize = '20px';
        splitIcon.style.lineHeight = '20px';
        splitIcon.style.width = '27px';
        splitIcon.style.height = '20px';
        splitIcon.style.display = 'inline-flex';
        splitIcon.style.alignItems = 'center';
        splitIcon.style.justifyContent = 'center';

        // Create submit button for split stage
        const splitStgButton = document.createElement('button');
        splitStgButton.appendChild(splitIcon);
        splitStgButton.style.width = '35px';
        splitStgButton.style.height = '30px';
        splitStgButton.style.color = 'orange';
        splitStgButton.title = context.language === 'EN' ? 'Split stage' : 'Partager l\'étape en deux';
        buttonsContainer.appendChild(splitStgButton);

        // Define submit handler (for split stage)
        async function splitStgHandler() {
            //alert(context.language === 'EN' ? 'Will be impleted soon!' : 'Sera implémenté prochainement !');
            const svgScissors = `
            <svg xmlns="http://www.w3.org/2000/svg"
                width="24"
                height="24"
                viewBox="0 0 640 640">
                <path fill="black" d="M256 320L216.5 359.5C203.9 354.6 190.3 352 176 352C114.1 352 64 402.1 64 464C64 525.9 114.1 576 176 576C237.9 576 288 525.9 288 464C288 449.7 285.3 436.1 280.5 423.5L563.2 140.8C570.3 133.7 570.3 122.3 563.2 115.2C534.9 86.9 489.1 86.9 460.8 115.2L320 256L280.5 216.5C285.4 203.9 288 190.3 288 176C288 114.1 237.9 64 176 64C114.1 64 64 114.1 64 176C64 237.9 114.1 288 176 288C190.3 288 203.9 285.3 216.5 280.5L256 320zM353.9 417.9L460.8 524.8C489.1 553.1 534.9 553.1 563.2 524.8C570.3 517.7 570.3 506.3 563.2 499.2L417.9 353.9L353.9 417.9zM128 176C128 149.5 149.5 128 176 128C202.5 128 224 149.5 224 176C224 202.5 202.5 224 176 224C149.5 224 128 202.5 128 176zM176 416C202.5 416 224 437.5 224 464C224 490.5 202.5 512 176 512C149.5 512 128 490.5 128 464C128 437.5 149.5 416 176 416z"/>
            </svg>
            `;
            map.getContainer().style.cursor = `url("data:image/svg+xml;utf8,${encodeURIComponent(svgScissors)}") 8 8, crosshair`;
        }
        splitStgButton.addEventListener('click', splitStgHandler);  // Associate submit handler with button
       
        // Create merge before stage icon
        const mergeBIcon = document.createElement('i');
        mergeBIcon.classList.add('fa-solid', 'fa-hand-holding-hand');
        mergeBIcon.style.fontSize = '20px';
        mergeBIcon.style.lineHeight = '20px';
        mergeBIcon.style.width = '27px';
        mergeBIcon.style.height = '20px';
        mergeBIcon.style.display = 'inline-flex';
        mergeBIcon.style.alignItems = 'center';
        mergeBIcon.style.justifyContent = 'center';

        // Create submit button for merge before
        const mergeBStgButton = document.createElement('button');
        mergeBStgButton.appendChild(mergeBIcon);
        mergeBStgButton.style.width = '35px';
        mergeBStgButton.style.height = '30px';
        mergeBStgButton.style.color = 'orange';
        mergeBStgButton.title = context.language === 'EN' ? 'Merge other stage before' : 'Fusionner autre étape avant';
        buttonsContainer.appendChild(mergeBStgButton);

        // Define submit handler (for merge before)
        async function mergeBStgHandler() {
            alert(context.language === 'EN' ? 'Will be impleted soon!' : 'Sera implémenté prochainement !');
        }
        mergeBStgButton.addEventListener('click', mergeBStgHandler);  // Associate submit handler with button
       
        // Create merge after stage icon
        const mergeAIcon = document.createElement('i');
        mergeAIcon.classList.add('fa-solid', 'fa-hand-holding-hand');
        mergeAIcon.style.fontSize = '20px';
        mergeAIcon.style.lineHeight = '20px';
        mergeAIcon.style.width = '27px';
        mergeAIcon.style.height = '20px';
        mergeAIcon.style.transform = 'scaleX(-1)';
        mergeAIcon.style.display = 'inline-flex';
        mergeAIcon.style.alignItems = 'center';
        mergeAIcon.style.justifyContent = 'center';

        // Create submit button for merge after
        const mergeAStgButton = document.createElement('button');
        mergeAStgButton.appendChild(mergeAIcon);
        mergeAStgButton.style.width = '35px';
        mergeAStgButton.style.height = '30px';
        mergeAStgButton.style.color = 'orange';
        mergeAStgButton.title = context.language === 'EN' ? 'Merge other stage after' : 'Fusionner autre étape après';
        buttonsContainer.appendChild(mergeAStgButton);

        // Define submit handler (for merge after)
        async function mergeAStgHandler() {
            alert(context.language === 'EN' ? 'Will be impleted soon!' : 'Sera implémenté prochainement !');
        }
        mergeAStgButton.addEventListener('click', mergeAStgHandler);  // Associate submit handler with button
       
        // Create delete stage icon
        const dsIcon = document.createElement('i');
        dsIcon.classList.add('fa-regular', 'fa-trash-can');
        dsIcon.style.fontSize = '20px';
        dsIcon.style.lineHeight = '20px';
        dsIcon.style.width = '27px';
        dsIcon.style.height = '20px';
        dsIcon.style.display = 'inline-flex';
        dsIcon.style.alignItems = 'center';
        dsIcon.style.justifyContent = 'center';

        // Create submit button for deleting the stage
        const delStgButton = document.createElement('button');
        delStgButton.appendChild(dsIcon);
        delStgButton.style.width = '35px';
        delStgButton.style.height = '30px';
        delStgButton.title = context.language === 'EN' ? 'Delete stage' : 'Supprimer l\'étape';
        buttonsContainer.appendChild(delStgButton);

        // Define submit handler (for deleting the stage)
        async function delStgHandler() {
            if (confirm(context.language === 'EN' ? "Are you sure you want to delete the edited stage?" : "Etes-vous sûr de vouloir supprimer l'étape en cours d'édition ?")) 
                deleteStg(context.editedStage);
        }
        delStgButton.addEventListener('click', delStgHandler);  // Associate submit handler with button
    
        // Create quit edition icon
        const qeIcon = document.createElement('i');
        qeIcon.classList.add('fa-solid', 'fa-arrow-right-from-bracket');
        qeIcon.style.fontSize = '20px';
        qeIcon.style.lineHeight = '20px';
        qeIcon.style.width = '27px';
        qeIcon.style.height = '20px';
        qeIcon.style.display = 'inline-flex';
        qeIcon.style.alignItems = 'center';
        qeIcon.style.justifyContent = 'center';

        // Create submit button for quitting edit mode
        const quitEdtButton = document.createElement('button');
        quitEdtButton.appendChild(qeIcon);
        quitEdtButton.style.width = '35px';
        quitEdtButton.style.height = '30px';
        quitEdtButton.title = context.language === 'EN' ? 'Quit stage edition' : 'Quitter édition de l\'étape';
        buttonsContainer.appendChild(quitEdtButton);

        // Define submit handler (for quitting edit mode)
        async function quitEdtHandler() {
            quitEditStage();
        }
        quitEdtButton.addEventListener('click', quitEdtHandler);  // Associate submit handler with button
       
        return [titleContainer, buttonsContainer];
    }

    //-----------------
    // Quit edit stage
    //-----------------
    function quitEditStage() {
        if (context.editedStage != null && stages[context.editedStage].points.length === 0)
            stages.splice(context.editedStage, 1);  // Remove empty stage

        setEnv4NonEdt();
    }

    //--------------------------------------------
    // Create command list control for stage edit
    //--------------------------------------------
    function createCmdListEdtStgControl() {
        // Create global container
        const container = L.DomUtil.create('div', 'info menu');
        container.style.maxWidth = '310px';
        container.style.boxSizing = 'border-box';
        container.style.display = 'flex';
        container.style.flexDirection = 'column';

        // Create header with arrow
        const header = L.DomUtil.create('div', 'menu-header', container);
        header.style.cursor = 'pointer';
        header.fontSize = '14px';
        header.fontWeight = 'bold';
        header.innerHTML = context.language === 'EN' ? '<strong>Mouse actions & keyboard shortcuts</strong> <span>▼</span>' : '<strong>Actions avec souris & raccourcis clavier</strong> <span>▼</span>';
        const arrow = header.querySelector('span');

        // Create list of commands
        const content = L.DomUtil.create('div', 'menu-content', container);
        content.style.fontSize = '12px';
        content.style.overflowY = context.spannedCommand ? 'auto' : 'hidden'; // scroll when expanded
        content.style.transition = 'max-height 0.3s ease';

        content.innerHTML = context.language === 'EN' ? `
            <br><strong>Create/edit stage:</strong><br>
            <table class="command-table">
                <tr>
                    <td><strong>Click on the map</strong></td>
                    <td>Add a new point to the<br>stage</td>
                </tr>
                <tr>
                    <td><strong>Double click on a<br>section of the stage</strong></td>
                    <td>Insert a point in the stage</td>
                </tr>
                <tr>
                    <td><strong>Double click on a<br>point of the stage</strong></td>
                    <td>Remove the point</td>
                </tr>
                <tr>
                    <td><strong>Drag & drop a point<br>or a section</strong></td>
                    <td>Modify the stage path</td>
                </tr>
                <tr>
                    <td><strong>n</strong></td>
                    <td>Set a name to the stage</td>
                </tr>
                <tr>
                    <td><strong>u</strong></td>
                    <td>Delete the last point of<br>the stage</td>
                </tr>
                <tr>
                    <td><strong>v</strong></td>
                    <td>Delete the first point of<br>the stage</td>
                </tr>
                <tr>
                    <td><strong>d</strong></td>
                    <td>Delete the stage</td>
                </tr>
                <tr>
                    <td><strong>Escape</strong></td>
                    <td>Quit editing the stage</td>
                </tr>
            </table>
            <br><strong>Global:</strong><br>
            <table class="command-table">
                <tr>
                    <td><strong>Double click on<br>the map</strong></td>
                    <td>Start creating a new stage</td>
                </tr>
                <tr>
                    <td><strong>Double click on<br>a stage</strong></td>
                    <td>Edit the stage</td>
                </tr>
                <tr>
                    <td><strong>e</strong></td>
                    <td>Export the route to a GPX file</td>
                </tr>
                <tr>
                    <td><strong>i</strong></td>
                    <td>Import a route from a GPX file</td>
                </tr>
                <tr>
                    <td><strong>r</strong></td>
                    <td>Reset the current route</td>
                </tr>
            </table>
        ` : `
            <br><strong>Création/modification d'étape:</strong><br>
            <table class="command-table">
                <tr>
                    <td><strong>Cliquer sur la carte</strong></td>
                    <td>Ajouter un nouveau<br>point à l'étape</td>
                </tr>
                <tr>
                    <td><strong>Double cliquer sur une<br>section de l'étape</strong></td>
                    <td>Insérer un point dans<br>l'étape</td>
                </tr>
                <tr>
                    <td><strong>Double cliquer sur un<br>point de l'étape</strong></td>
                    <td>Supprimer le point</td>
                </tr>
                <tr>
                    <td><strong>Tirer-déposer un point<br>ou une section</strong></td>
                    <td>Modifier le tracé de l'étape</td>
                </tr>
                <tr>
                    <td><strong>n</strong></td>
                    <td>Attribuer un nom à<br>l'étape</td>
                </tr>
                <tr>
                    <td><strong>u</strong></td>
                    <td>Supprimer le dernier<br>point de l'étape</td>
                </tr>
                <tr>
                    <td><strong>v</strong></td>
                    <td>Supprimer le premier<br>point de l'étape</td>
                </tr>
                <tr>
                    <td><strong>d</strong></td>
                    <td>Supprimer l'étape</td>
                </tr>
                <tr>
                    <td><strong>Echappement</strong></td>
                    <td>Terminer la création/<br>modification d'étape</td>
                </tr>
            </table>
            <br><strong>Générales :</strong><br>
            <table class="command-table">
                <tr>
                    <td><strong>Double cliquer sur<br>la carte</strong></td>
                    <td>Commencer la création<br>d'une nouvelle étape</td>
                </tr>
                <tr>
                    <td><strong>Double cliquer sur<br>une étape</strong></td>
                    <td>Modifier l'étape</td>
                </tr>
                <tr>
                    <td><strong>e</strong></td>
                    <td>Exporter l'itinéraire dans un<br>fichier GPX</td>
                </tr>
                <tr>
                    <td><strong>i</strong></td>
                    <td>Importer un itinéraire d'un<br>fichier GPX</td>
                </tr>
                <tr>
                    <td><strong>r</strong></td>
                    <td>Réinitialiser l'itinéraire<br>en cours</td>
                </tr>
            </table>
        `;

        // Adjust max height to content
        if (context.spannedCommand) {
            content.style.maxHeight = '0';       // collapse
            content.style.overflow = 'hidden';

            requestAnimationFrame(() => {
            const mapContainer = map.getContainer(); // Leaflet map container
            const mapHeight = mapContainer.clientHeight;
            const containerRect = container.getBoundingClientRect();
            const availableHeight = mapHeight - containerRect.top - 10; // 10px padding
            content.style.maxHeight = availableHeight + 'px';   // Expand
            content.style.overflowY = 'auto';
            });
        } else {
            content.style.maxHeight = '0';       // Collapse
            content.style.overflow = 'hidden';
        }

        // Select arrow shape
        arrow.textContent = context.spannedCommand ? '▲' : '▼';

        // Handle clicks on the arrow
        L.DomEvent.on(header, 'click', () => {
            context.spannedCommand = !context.spannedCommand;

            // Adjust max height to content
            if (context.spannedCommand) {
                const mapContainer = map.getContainer(); // Leaflet map container
                const mapHeight = mapContainer.clientHeight;
                const containerRect = container.getBoundingClientRect();
                const availableHeight = mapHeight - containerRect.top - 10; // 10px padding

                content.style.maxHeight = availableHeight + 'px';   // Expand
                content.style.overflowY = 'auto';
            } else {
                content.style.maxHeight = '0';       // Collapse
                content.style.overflow = 'hidden';
            }

            arrow.textContent = context.spannedCommand ? '▲' : '▼';
        });

        return container;
    }

    //------------------------
    // Create new empty stage
    //------------------------
    function createNewEmptyStage() {
        stages.push({   // Push new empty stage into route array
            name: null,     // Stage name
            points: [],     // Points defined by the user (not calculated by the router). Represented by circle markers on the map
            sections: [],   // Sections between points (straight or calculated by router). Represented by polylines on the map
            distance: 0,    // Stage length
            ascent: null,   // Stage ascent
            descent: null,  // Stage descent
            infoPop: null   // Information to be displayed when requested about the stage
        });
    
        context.editedStage = stages.length - 1;    // Register stage number as the currently edited stage

        return stages.length - 1;
    }

    //------------------------------------------------------------
    // Set document and map event listeners for edit stage status
    //------------------------------------------------------------
    function setDocMap4EdtStg(i) {
        context.editedStage = i;    // Record edited stage number

        let holdTimer = null;
        let longPressTriggered = false;

        // Delete non permanent event listeners on doc
        for (const { target, type, handler } of documentEvtList)
            target.removeEventListener(type, handler);
        documentEvtList.splice(0);  // Remove event listeners from registered list

        // Set non permanent event listeners for key down on doc (for stage edition)
        function doc_keydown(e) {    
            if (context.operationWithButtonInProcess) return;   // Do not execute if save of rename operation in process

            const key = (e.key || '').toLowerCase();

            // If the user is typing in an input or textarea, ignore shortcuts
            const tag = (e.target && e.target.tagName || '').toLowerCase();
            if (tag === 'input' || tag === 'textarea' || e.target.isContentEditable) {
                return; // don't handle t, r, s, etc.
            }

            if (key === 'escape') {     // When user presses 'escape' (to quit edit mode)
                quitEditStage();
            } else if (key === 'd') {     // When user presses 'd' (to delete current stage)
                if (confirm(context.language === 'EN' ? "Are you sure you want to delete the edited stage?" : "Etes-vous sûr de vouloir supprimer l'étape en cours d'édition ?")) 
                    deleteStg(context.editedStage);
            } else if (key === 'n') {     // When user presses 'n' (to set/change stage name)
                setStgName();
            } else if (key === 'u') {     // When user presses 'u' (to delete stage's last point)
                deleteLastPoint();
            } else if (key === 'v') {     // When user presses 'v' (to delete stage's first point)
                deleteFirstPoint();
            } else if (key === 'e') {   // When user presses 'e' (to save the route to a GPX file)
                exportRouteToGPX();
            } else if (key === 'i') {   // When user presses 'i' (to load a route from a GPX file)
                importRouteFromGPX();
            } else if (key === 'r') {   // When user presses 'r' (to reverse the stage's direction)
                reverseStage();
            } else if (key === 'z') {   // When user presses 'z' (to reset the route)
                if (confirm(context.language === 'EN' ? "Are you sure you want to reset the route?" : "Etes-vous sûr de vouloir réinitialiser l'itinéraire ?")) 
                    resetRoute();
            }
        }
        document.addEventListener('keydown', doc_keydown);      // Add event listener to document
        documentEvtList.push({ target: document, type: 'keydown', handler: doc_keydown });  // Record event listener

        map.getContainer().style.cursor = 'crosshair';

        // Delete non permanent event listeners on map
        for (const { target, type, handler } of mapEvtList)
            target.removeEventListener(type, handler);
        mapEvtList.splice(0);  // Remove event listeners from registered list

        // Set event listener on map for simple click
        const map_click = (function(stageRef) {
            return function(e) {
                const iRef = stages.indexOf(stageRef);
                if (iRef === -1) return;

                if (context.operationWithButtonInProcess) return;
            
                // If a double-click is coming, cancel this click
                if (context.clickTimeout) {
                    clearTimeout(context.clickTimeout);
                    context.clickTimeout = null;
                }

                // If a drag just happened, skip this click
                if (context.suppressNextClick) {
                    context.suppressNextClick = false;      // Reset for next time
                    return;
                }
  
                context.clickTimeout = setTimeout(async () => {     // Delay the action of 350 ms to see if a dblclick follows
                    context.clickTimeout = null;
            
                    let latlng = e.latlng;      // Extract click coordinates

                    let calculatedPoints = null;
                    if (context.routerProfile && stageRef.points.length > 0) {     // Not first point of stage and use BRouter
                        // Search a route to this point with BRouter
                        const lastPointLatlng = stageRef.points[stageRef.points.length - 1].marker.getLatLng();    // Retrieve previous point coordinates
                        const coordinates = lastPointLatlng.lng + "," + lastPointLatlng.lat + "|" +
                            latlng.lng + "," + latlng.lat;      // Prepare coordinates to be submitted to BRouter
                        calculatedPoints = await fetchBRouterRoute(coordinates);    // Find route to new point with BRouter
                        if (!calculatedPoints) {      // When no route is found by BRouter
                            //alert(context.language === 'EN' ? "Failed to find a path to this location" : "Aucun chemin trouvé pour ce lieu");
                            return;
                        }
                        calculatedPoints = simplifyPolyGeom(calculatedPoints);  // Simplify geometry of new section by removing part of the points
                        latlng = calculatedPoints[calculatedPoints.length - 1];     // Adjust new point's position using BRouter response
                        
                        // Adjust previous point's and previous section's positions using BRouter response
                        const latlng0 = calculatedPoints[0];
                        stageRef.points[stageRef.points.length - 1].marker.setLatLng(latlng0); // Adjust last point's position
                        if (stageRef.sections[0]) { // When there are sections in the stage, adjust last section's end position
                            let latlngs = stageRef.sections[stageRef.sections.length - 1].polyline.getLatLngs()
                            latlngs.pop()
                            latlngs.push(latlng0);
                            stageRef.sections[stageRef.sections.length - 1].polyline.setLatLngs(latlngs);
                        }
                    } else if (context.routerProfile && stageRef.points.length === 0) {    // First point and use BRouter
                        // Search the nearest reachable point with BRouter
                        const coordinates = latlng.lng + "," + latlng.lat + "|" +
                            latlng.lng + "," + latlng.lat;
                        calculatedPoints = await fetchBRouterRoute(coordinates);
                        if (!calculatedPoints) {   // No route found
                            //alert(context.language === 'EN' ? "Failed to find a path to this location" : "Aucun chemin trouvé pour ce lieu");
                            return;
                        }
                        latlng = calculatedPoints[0];       // Adjust position to be assigned to new point
                    } else if (stageRef.points.length > 0) {       // Not first point and do not use BRouter
                        calculatedPoints = [stageRef.points[stageRef.points.length - 1].marker.getLatLng(), latlng];     // Two points array  to be used to create polyline
                    }

                    // Create and record point
                    const newCircleMarker = L.circleMarker(latlng, { pane: 'markerPaneTop', draggable: true, autoPan: false, bubblingMouseEvents: true })
                        .addTo(map);    // Create marker to represent the point on the map
                    stageRef.points.push({marker: newCircleMarker, evtList: []});   // Add point to stage

                    setPoint4Edt(iRef, stageRef.points.length - 1);     // Set new point's layout and event listeners for edit mode

                    // Adjust layout of previous point 
                    if (stageRef.points.length > 2) {
                        stageRef.points[stageRef.points.length - 2].marker.setStyle({ radius: markerSize.small, 
                            opacity: 1, fillOpacity: 0, color: routeColors.editRoute });
                    } else if (stageRef.points.length > 1) {
                        stageRef.points[stageRef.points.length - 2].marker.setStyle({ radius: markerSize.medium, 
                            opacity: 1, fillOpacity: 0, color: routeColors.editDeparture });
                    }
                
                    // Add a section and update distance
                    if (stageRef.points.length > 1) {  // When not first point
                        const polylineRef = L.polyline(calculatedPoints).addTo(map);    // Create polyline to represent section on the map                   
                        stageRef.sections.push({polyline: polylineRef, evtList:[]});    // Add section to stage

                        setSection4Edit(iRef, stageRef.sections.length - 1);    // Set new section's layout and event listeners for edit mode
        
                        stageRef.distance = stageRef.distance + calculateDistance(calculatedPoints);    // Update stage distance
                    }
                  
                    calculateAscentAndDescent(stageRef);    // Calculate/update ascent and descent for the stage

                    updateInfoPopup(stageRef, true);  // Update information to be displayed about the stage
                }, 350);
            };
        })(stages[i]);
        map.addEventListener('click', map_click);       // Add event listener to map
        mapEvtList.push({ target: map, type: 'click', handler: map_click });    // Register event listener

        // Set event listener on map for double-click
        function map_dblclick(e) {
            // Cancel single-click if double-click detected
            if (context.clickTimeout) {
                clearTimeout(context.clickTimeout);
                context.clickTimeout = null;
            }

            quitEditStage();    // Finish editing the current stage
                    
            setEnv4EdtStg(null);    // Start editing a new stage
        }
        map.addEventListener('dblclick', map_dblclick);     // Add listener to map
        mapEvtList.push({ target: map, type: 'dblclick', handler: map_dblclick });    //Register listener

        // On real pan start
        function map_dragstart(e) {
            map.getContainer().style.cursor = 'grabbing';
            context.suppressNextClick = true;
        }
        map.addEventListener('dragstart', map_dragstart);   // Add event listener to map
        mapEvtList.push({ target: map, type: 'dragstart', handler: map_dragstart });    //Register listener

        // On pan end
        function map_dragend(e) {
            map.getContainer().style.cursor = 'crosshair';
            context.suppressNextClick = false;
        }
        map.addEventListener('dragend', map_dragend);   // Add event listener to map
        mapEvtList.push({ target: map, type: 'dragend', handler: map_dragend });    //Register listener

        function map_mousedown(e) {
            longPressTriggered = false;

            holdTimer = setTimeout(() => {
                longPressTriggered = true;
                map.getContainer().style.cursor = 'grabbing';
                context.suppressNextClick = true;   // key line
            }, 350);
        }
        map.addEventListener('mousedown', map_mousedown);   // Add event listener to map
        mapEvtList.push({ target: map, type: 'mousedown', handler: map_mousedown });    //Register listener

        function map_mouseup(e) {
            clearTimeout(holdTimer);
            map.getContainer().style.cursor = 'crosshair';
            //context.suppressNextClick = false;
        }
        map.addEventListener('mouseup', map_mouseup);   // Add event listener to map
        mapEvtList.push({ target: map, type: 'mouseup', handler: map_mouseup });    //Register listener
    }

    //------------------------------------------------------------
    // Set stage layout and event listeners for edit stage status
    //------------------------------------------------------------
    function setStg4EdtStg(i) {
        if (i != null) {
            if (stages[i] && stages[i].sections)
                setSections4Edit(i);    // Set sections' layout and event listeners for edit status

            if (stages[i] && stages[i].points)
                setPoints4Edit(i);      // Set points' layout and event listeners for edit status

            if (stages[i] && stages[i].points.length > 0) {
                // Update stage information to be displayed in popup and show it (if selected)
                updateInfoPopup(stages[i], true);
                if (context.displayInfo) {
                    showInfoPopup(stages[i]);
                }
            }
        }
    }

    //------------------------------
    // Set sections for edit stage 
    //------------------------------
    function setSections4Edit(i) {
        for (let j = 0; j < stages[i].sections.length; j++) {
            setSection4Edit(i, j);  // Set section's layout and event listeners for edit status
        }
    }

    //--------------------------------------------------------------
    // Set section layout and event listeners for edit stage status
    //---------------------------------------------------------------
    function setSection4Edit(i, j) {
        const stage = stages[i];
        const section = stage.sections[j];

        // Bring to the front
        section.polyline.bringToFront();

        // Set section's layout
        section.polyline.setStyle({ color: routeColors.editRoute, weight: routeWeights.editRoute, opacity: 1, fillOpacity: 0 });

        // Delete event listeners on section
        for (const { target, type, handler } of section.evtList)    // Remove event listeners
            target.removeEventListener(type, handler);  
        section.evtList.splice(0);  // Clear event listener list

        // Set event listener on section for click
        function section_click(e) {
            if (context.operationWithButtonInProcess) return;   // Ignore if a save or rename operation is in process

            // If a double-click is coming, cancel this click
            if (context.clickTimeout) {
                clearTimeout(context.clickTimeout);
                context.clickTimeout = null;
            }

            // Do nothing when simple click
            clickTimeout = setTimeout(() => {
                context.clickTimeout = null;
            }, 350);
        };
        section.polyline.addEventListener('click', section_click);  // Add event listener to map
        section.evtList.push({ target: section.polyline, type: 'click', handler: section_click });    // Register event listener

        // Set event listener on section for double-click
        const section_dblclick = (function(stageRef, sectionRef) {
            return function(e) {
                if (context.operationWithButtonInProcess) return;   // Ignore if a save or rename operation is in process
                
                const iRef = stages.indexOf(stageRef);  // Retrieve stage index
                if (iRef === -1) return;
                const jRef = stageRef.sections.indexOf(sectionRef); // Retrieve section index
                if (jRef === -1) return;

                // Stop the pending single-click
                if (context.clickTimeout) {
                    clearTimeout(context.clickTimeout);
                    context.clickTimeout = null;
                }
    
                L.DomEvent.stopPropagation(e);  // Prevent map click from firing

                const eLatLng = e.latlng;   // Retrieve clicked coordinates
                const latlngs = sectionRef.polyline.getLatLngs();   // Retrieve section points
                const {index: idx, point: latlng} = findClosestSectionAndPoint(latlngs, e.latlng);  // Find section point closest to the clicked point

                if (idx >= 0) {     // When closest point was found
                    const latlngs1 = latlngs.slice(0, idx + 1);     // Retrieve the points before the closest point (including it)
                    latlngs1.push(latlng);  // Add the clicked point
                    const latlngs2 = [latlng].concat(latlngs.slice(idx + 1)); // Retrieve the point after the closest points and concat the clicked point at the beginning
                    sectionRef.polyline.setLatLngs(latlngs1);   // Update the section with the points before and up to the clicked point
                    // Insert a new section with the clicked point and the points after it                
                    stageRef.sections.splice(jRef + 1, 0, {polyline: L.polyline(latlngs2).addTo(map), evtList: []});

                    setSection4Edit(iRef, jRef + 1);    // Set new section's layout and event listeners for edit mode
                            
                    const newCircleMarker2 = L.circleMarker(latlng, { pane: 'markerPaneTop', draggable: true, autoPan: false, bubblingMouseEvents: true })
                        .addTo(map);    // Create circle marker for the new point

                    stageRef.points.splice(jRef + 1, 0, {marker: newCircleMarker2, evtList: []});   // Add new point to stage points

                    setPoint4Edt(iRef, jRef + 1);   // Set new point's llayout and event listeners for edit mode

                    // Update stage information to be displayed in popup and show it (if selected)
                    updateInfoPopup(stageRef, true);
                    if (context.displayInfo) {
                        showInfoPopup(stageRef);
                    }

                    context.suppressNextClick = true;   // To prevent firing the single click handler
                }
            };
        })(stage, section);
        section.polyline.addEventListener('dblclick', section_dblclick);    // Add event listner to section
        section.evtList.push({ target: section.polyline, type: 'dblclick', handler: section_dblclick });   // Register event listener 

        // Set event listener on section for drag and drop
        const section_mousedown = (function(stageRef, sectionRef) {
            return function(e) {
                if (context.operationWithButtonInProcess) return;   // Ignore if a save or rename operation is in process

                map.dragging.disable(); // Prevent map panning

                const DRAG_THRESHOLD = 5;   // Minimal move detected: 5 pixels
                let startPoint = map.mouseEventToContainerPoint(e);
                let isDragging = false;
                let firstDrag = true;
                
                const iRef = stages.indexOf(stageRef);  // Retrieve stage index
                if (iRef === -1) return;
                const jRef = stageRef.sections.indexOf(sectionRef);     // Retrieve section index
                if (jRef === -1) return;

                const initPolylineLatlngs = sectionRef.polyline.getLatLngs();   // Save initial section's points

                const move = ev => {    // Event: mouse cursor moved
                    const p = map.mouseEventToContainerPoint(ev);
                    if (!isDragging && p.distanceTo(startPoint) < DRAG_THRESHOLD) {
                        return;     // Move is too small
                    }

                    if (!isDragging) {
                        isDragging = true;  // Register dragging in process
                        context.suppressNextClick = true;
                    
                        map.dragging.disable();
                    }

                    // Prevent event propagation to map
                    L.DomEvent.stopPropagation(e);
                    L.DomEvent.preventDefault(e);

                    if (firstDrag) {
                        const latlngs = sectionRef.polyline.getLatLngs();
                        // Replace section's polyline with a straignt dashed polyline from the section's origin to the mouse cursor's position
                        sectionRef.polyline.setLatLngs([latlngs[0], ev.latlng])
                            .setStyle({ dashArray: '5, 10' });
                        // Insert a new section with a straight dashed polyline from the mouse cursor's position to the section's end
                        const newPolyline = L.polyline([ev.latlng, latlngs[latlngs.length - 1]]).addTo(map);
                        newPolyline.setStyle({ dashArray: '5, 10' });
                        stageRef.sections.splice(jRef + 1, 0, {polyline: newPolyline, evtList: []});
                        
                        firstDrag = false;
                    } else {
                        // Update the section preceding the mouse cursor's position
                        const latlngs = sectionRef.polyline.getLatLngs();
                        sectionRef.polyline.setLatLngs([latlngs[0], ev.latlng])
                            .setStyle({ dashArray: '5, 10' });
                        // Update the section following the mouse cursor's position
                        const nextLatlngs = stageRef.sections[jRef + 1].polyline.getLatLngs();
                        stageRef.sections[jRef + 1].polyline.setLatLngs([ev.latlng, nextLatlngs[nextLatlngs.length - 1]]);
                    }
                };

                const up = async ev => {    // Event: mouse button up
                    if (!isDragging) {  // Ignore if no dragging is in process
                        cleanupDrag();
                        return;
                    }

                    // Prevent event propagation to map
                    L.DomEvent.stopPropagation(e);
                    L.DomEvent.preventDefault(e);

                    let latlng = map.mouseEventToLatLng(ev);

                    let calculatedPoints1 = null;
                    let calculatedPoints2 = null;
                    if (context.routerProfile) {    // When BRouter used
                        const pointBeforeLatlng = stageRef.points[jRef].marker.getLatLng();     // Retrieve preceding point's coordinates
                        const pointAfterLatlng = stageRef.points[jRef + 1].marker.getLatLng();  // Retrieve next point's coordinates
                        // Prepare request to BRouter with prceding point's, current cursor point's and next point's coordinates
                        const coordinates = pointBeforeLatlng.lng + "," + 
                            pointBeforeLatlng.lat + "|" + latlng.lng + "," + latlng.lat + "|" + 
                            pointAfterLatlng.lng + "," + pointAfterLatlng.lat;
                        let calculatedPoints = await fetchBRouterRoute(coordinates);    // Query BRouter for a route
                        if (!calculatedPoints) {    // When no route found by BRouter, restore initial section
                            //alert(context.language === 'EN' ? "Failed to find a path to this location" : "Aucun chemin trouvé pour ce lieu");
                            sectionRef.polyline.setLatLngs(initPolylineLatlngs)
                                .setStyle({ dashArray: null });
                            stageRef.sections[jRef + 1].polyline.remove();
                            stageRef.sections.splice(jRef + 1, 1);
                            cleanupDrag();
                            return;
                        }
                        // Find closest point (from the cursor's position) in the route returned by BRouter
                        const closestSegAndPt = findClosestSectionAndPoint(calculatedPoints, latlng);
                        const idx = closestSegAndPt.index;
                        const closestPt = closestSegAndPt.point;
                        // Prepare set of points before the cursor's position (and finishing with it)
                        calculatedPoints1 = calculatedPoints.slice(0, idx + 1);
                        calculatedPoints1.push(closestPt);
                        calculatedPoints1 = simplifyPolyGeom(calculatedPoints1);    // Get rid of part of the points (not to handle too many data)
                        // Prepare set of points after the cursor's position (and starting with it)
                        calculatedPoints2 = [closestPt].concat(calculatedPoints.slice(idx + 1));
                        calculatedPoints2 = simplifyPolyGeom(calculatedPoints2);    // Get rid of part of the points (not to handle too many data)
                        latlng = closestPt;
        
                        // Adjust previous point's and previous section's positions
                        const latlng0 = calculatedPoints1[0];
                        stageRef.points[jRef].marker.setLatLng(latlng0);
                        if (stageRef.sections[jRef - 1]) {
                            let latlngs = stageRef.sections[jRef - 1].polyline.getLatLngs()
                            latlngs.pop();
                            latlngs.push(latlng0);
                            stageRef.sections[jRef - 1].polyline.setLatLngs(latlngs);
                        }
                        // Adjust next point's and next section's positions
                        const latlngx = calculatedPoints2[calculatedPoints2.length - 1];
                        stageRef.points[jRef + 1].marker.setLatLng(latlngx);
                        if (stageRef.sections[jRef + 2]) {
                            let latlngs = stageRef.sections[jRef + 2].polyline.getLatLngs()
                            latlngs.shift();
                            latlngs = [latlngx].concat(latlngs);
                            stageRef.sections[jRef + 2].polyline.setLatLngs(latlngs);
                        }
                    } else {    // When BRouter no used, prepare set of points
                        calculatedPoints1 = [stageRef.points[jRef].marker.getLatLng(), latlng];
                        calculatedPoints2 = [latlng, stageRef.points[jRef + 1].marker.getLatLng()];
                    }

                    // Update section before cursor's position
                    sectionRef.polyline.setLatLngs(calculatedPoints1)
                        .setStyle({ dashArray: null });                        
                    // Update section after cursor's position
                    stageRef.sections[jRef + 1].polyline.setLatLngs(calculatedPoints2)
                        .setStyle({ dashArray: null });

                    setSection4Edit(iRef, jRef + 1);    // Set layout and event listeners on added section (after the cursur's position) for edit mode

                    // Update stage's distance
                    stageRef.distance = stageRef.distance
                        - calculateDistance(initPolylineLatlngs)
                        + calculateDistance(calculatedPoints1)
                        + calculateDistance(calculatedPoints2);

                    // Insert new point represented with circle marker at the cursor's position
                    const newMarker = L.circleMarker(latlng).addTo(map);
                    stageRef.points.splice(jRef + 1, 0, {marker: newMarker, evtList: []});

                    setPoint4Edt(iRef, jRef + 1);   // Set layout and event listners on added point for edit mode
                    
                    calculateAscentAndDescent(stageRef);    // Calculate/update ascent/descent

                    updateInfoPopup(stageRef, true);  // Updates stage's information to be displayed

                    cleanupDrag();
                };

                // Use DOM events from the map container to ensure firing consistency
                const moveHandler = ev => {
                    const latlng = map.mouseEventToLatLng(ev);
                    move({ latlng });
                };
                const upHandler = up;

                // Function for cleaning up event listeners from document
                const cleanupDrag = () => {
                    document.removeEventListener('mousemove', moveHandler);
                    document.removeEventListener('mouseup', upHandler);
                    map.dragging.enable();
                };

                // Add event listeners to document
                document.addEventListener('mousemove', moveHandler);
                document.addEventListener('mouseup', upHandler);
            };
        })(stage, section);
        section.polyline.addEventListener('mousedown', section_mousedown);  // Add event listener to section
        section.evtList.push({ target: section.polyline, type: 'mousedown', handler: section_mousedown });  // Register event listener
    }

    //-----------------------------------
    // Set points for edit stage status
    //-----------------------------------
    function setPoints4Edit(i) {
        for (let j = 0; j < stages[i].points.length; j++) {
            setPoint4Edt(i, j);     // Set point layout and event listeners for edit stage status
        }
    }

    //-------------------------------------------------------------
    // Set point layout and event listeners for edit stage status
    //-------------------------------------------------------------
    function setPoint4Edt(i, j) {
        const stage = stages[i];
        const point = stage.points[j];

        // Bring to the front
        point.marker.bringToFront();

        // Set point layout
        if (stage.points.length === 1)
            point.marker.setStyle({ radius: markerSize.medium, opacity: 1, fillOpacity: 0, color: routeColors.editSingle });
        else if (j === 0)
            point.marker.setStyle({ radius: markerSize.medium, opacity: 1, fillOpacity: 0, color: routeColors.editDeparture });
        else if (j < stage.points.length - 1)
            point.marker.setStyle({ radius: markerSize.small, opacity: 1, fillOpacity: 0, color: routeColors.editRoute });
        else
            point.marker.setStyle({ radius: markerSize.large, opacity: 1, fillOpacity: 0, color: routeColors.editArrival });

        // Delete event listeners on point
        if (point.evtList) {
            for (const { target, type, handler } of point.evtList) {
                target.removeEventListener(type, handler);
            }
    
            point.evtList.splice(0);
        }

        // Set event listener on point for click
        function point_click(e) {
            if (context.operationWithButtonInProcess) return;   // Ignore if load or rename operation in process

            if (context.suppressNextClick) {
                context.suppressNextClick = false;
                L.DomEvent.stopPropagation(e);      // Do not propagate to the map
                L.DomEvent.preventDefault(e);
                return;
            }
            
            if (context.clickTimeout) {     // Clear existing tieout if ny
                clearTimeout(context.clickTimeout);
                context.clickTimeout = null;
            }

            // Execute a timeout of 350 ms, to make sure it is a simple click and not a double click
            context.clickTimeout = setTimeout(() => {
                context.clickTimeout = null;
            }, 350);
        }
        point.marker.addEventListener('click', point_click);    // Add event listener  to point
        point.evtList.push({ target: point.marker, type: 'click', handler: point_click });  // Register event listener    

        // Set event listener on point for double-click
        const point_dblclick = (function(stageRef, pointRef) {
            return async function(e) {
                if (context.operationWithButtonInProcess) return;   // Ignore if load or rename operation in process

                context.suppressNextClick = true;    // To prevent firing the single click handler
                
                L.DomEvent.stopPropagation(e);  // Do not propagate to map (stop zooming and bubbling)
                L.DomEvent.preventDefault(e);
                
                // Stop the pending single-click
                if (context.clickTimeout) {
                    clearTimeout(context.clickTimeout);
                    context.clickTimeout = null;
                }

                const iRef = stages.indexOf(stageRef);  // Retrieve stage index
                if (iRef === -1) return;
                const jRef = stageRef.points.indexOf(pointRef); // Retrieve point index
                if (jRef === -1) return;

                if (jRef > 0 && jRef < stageRef.points.length - 1) {     // Not the first nor le last point 
                    let calculatedPoints = null;
                    if (context.routerProfile) {    // BRouter must be used
                        const pointBeforeLatlng = stageRef.points[jRef - 1].marker.getLatLng();     // Regtrieve coordinates of point preceding the clicked point
                        const pointAfterLatlng = stageRef.points[jRef + 1].marker.getLatLng();      // Regtrieve coordinates of point following the clicked point
                        const coordinates = pointBeforeLatlng.lng + "," + pointBeforeLatlng.lat + "|" +     // Prepare request for BRouter
                            pointAfterLatlng.lng + "," + pointAfterLatlng.lat;
                        calculatedPoints = await fetchBRouterRoute(coordinates);    // Query BRouter for a route
                        if (!calculatedPoints) {   // When no route found
                            //alert(context.language === 'EN' ? "Failed to find a path to this location" : "Aucun chemin trouvé pour ce lieu");
                            return;
                        }
                        calculatedPoints = simplifyPolyGeom(calculatedPoints);  // Simplify geometry of new section by removing part of the points
        
                        // Adjust previous point's and previous section's positions
                        const latlng0 = calculatedPoints[0];
                        stageRef.points[jRef - 1].marker.setLatLng(latlng0);
                        if (stageRef.sections[jRef - 2]) {
                            // Remove previous coordinates and replace with new ones
                            let latlngs = stageRef.sections[jRef - 2].polyline.getLatLngs()
                            latlngs.pop();
                            latlngs.push(latlng0);
                            stageRef.sections[jRef - 2].polyline.setLatLngs(latlngs);
                        }
                        // Adjust next point's and next section's positions
                        const latlngx = calculatedPoints[calculatedPoints.length - 1];
                        stageRef.points[jRef + 1].marker.setLatLng(latlngx);
                        if (stageRef.sections[jRef + 1]) {
                            // Remove previous coordinates and replace with new ones
                            let latlngs = stageRef.sections[jRef + 1].polyline.getLatLngs()
                            latlngs.shift();
                            latlngs = [latlngx].concat(latlngs);
                            stageRef.sections[jRef + 1].polyline.setLatLngs(latlngs);
                        }
                    } else { 
                        calculatedPoints = [stageRef.points[jRef - 1].marker.getLatLng(), 
                            stageRef.points[jRef + 1].marker.getLatLng()];
                    }

                    // Update stage's distance
                    stageRef.distance = stageRef.distance
                        - calculateDistance(stageRef.sections[jRef - 1].polyline.getLatLngs())
                        - calculateDistance(stageRef.sections[jRef].polyline.getLatLngs())
                        + calculateDistance(calculatedPoints);

                    // Remove event listeners on point and preceding and following sections
                    for (const { target, type, handler } of stageRef.sections[jRef - 1].evtList)
                        target.removeEventListener(type, handler);
                    for (const { target, type, handler } of stageRef.sections[jRef].evtList)
                        target.removeEventListener(type, handler);
                    for (const { target, type, handler } of stageRef.points[jRef].evtList)
                        target.removeEventListener(type, handler);

                    // Remove point
                    stageRef.points[jRef].marker.remove();
                    stageRef.points.splice(jRef, 1);

                    // Remove preceding and following sections and replace them with a single section
                    stageRef.sections[jRef -1].polyline.remove();
                    stageRef.sections[jRef].polyline.remove();                    
                    stageRef.sections.splice(jRef - 1, 2);
                    stageRef.sections.splice(jRef - 1, 0, {polyline: L.polyline(calculatedPoints).addTo(map),
                        evtList: []});

                    // Set section layout and event listeners for edit stage mode
                    setSection4Edit(iRef, jRef - 1);

                    // Calculate/update stage ascent/descent
                    calculateAscentAndDescent(stageRef);
                    
                    // Update information to be displayed for the stage
                    updateInfoPopup(stageRef, true);
                    if (context.displayInfo)
                        showInfoPopup(stageRef);
                } else if (jRef === 0 && stageRef.points.length > 1) {     // First point of several
                    // Update stage distance
                    stageRef.distance = stageRef.distance
                        - calculateDistance(stageRef.sections[0].polyline.getLatLngs());

                    // Remove event listeners on point and following section
                    for (const { target, type, handler } of stageRef.sections[0].evtList)
                        target.removeEventListener(type, handler);
                    for (const { target, type, handler } of pointRef.evtList)
                        target.removeEventListener(type, handler);

                    // Remove point and following section
                    stageRef.sections[0].polyline.remove();0
                    stageRef.sections.shift();
                    pointRef.marker.remove();
                    stageRef.points.shift();

                    // Update layout of next point (now first one)
                    if (stageRef.points.length > 1)
                        stageRef.points[0].marker.setStyle({ radius: markerSize.medium, opacity: 1, fillOpacity: 0, color: routeColors.editDeparture });
                    else
                        stageRef.points[0].marker.setStyle({ radius: markerSize.medium, opacity: 1, fillOpacity: 0, color: routeColors.editSingle });
                    
                    // Calculate/update stage ascent/descent
                    calculateAscentAndDescent(stageRef);

                    // Update information to be displayed for the stage
                    updateInfoPopup(stageRef, true);
                    if (context.displayInfo)
                        showInfoPopup(stageRef);
                } else if (stageRef.points.length > 1) {       // Last point
                    // Update stage distance
                    stageRef.distance = stageRef.distance
                        - calculateDistance(stageRef.sections[jRef - 1].polyline.getLatLngs());

                    // Remove event listeners on point and preceding section
                    for (const { target, type, handler } of stageRef.sections[jRef - 1].evtList)
                        target.removeEventListener(type, handler);
                    for (const { target, type, handler } of pointRef.evtList)
                        target.removeEventListener(type, handler);

                    // Remove point and preceding section
                    stageRef.sections[jRef - 1].polyline.remove();
                    stageRef.sections.pop();
                    pointRef.marker.remove();
                    stageRef.points.pop();

                    // Update layout of next point (now first one)
                    if (stageRef.points.length > 1)
                        stageRef.points[stageRef.points.length - 1].marker.setStyle(
                        { radius: markerSize.large, opacity: 1, fillOpacity: 0, color: routeColors.editArrival });
                    else
                        stageRef.points[stageRef.points.length - 1].marker.setStyle(
                        { radius: markerSize.medium, opacity: 1, fillOpacity: 0, color: routeColors.editSingle });

                    // Calculate/update stage ascent/descent
                    calculateAscentAndDescent(stageRef);

                    // Update information to be displayed for the stage
                    updateInfoPopup(stageRef, true);
                    if (context.displayInfo)
                        showInfoPopup(stageRef);
                } else {    // First and only point
                    // Remove event listeners
                    for (const { target, type, handler } of pointRef.evtList)
                        target.removeEventListener(type, handler);

                    // Remove point
                    pointRef.marker.remove();

                    // Remove information popup
                    if (stageRef.infoPop)
                        stageRef.infoPop.remove();

                    stages.splice(iRef, 1);

                    context.editedStage = null;

                    // Set environment to non edit mode
                    setEnv4NonEdt();
                }

                context.suppressNextClick = false;    // Enable single click again
            };
        })(stage, point);
        point.marker.addEventListener('dblclick', point_dblclick);      // Add event listener to point
        stage.points[j].evtList.push({ target: point.marker, type: 'dblclick', handler: point_dblclick });    // Register event listener
        
        // Set event listener on point for drag and drop
        const point_mousedown = (function(stageRef, pointRef) {
            return function(e) {
                if (context.operationWithButtonInProcess) return;   // Ignore if load or rename operation in process

                map.dragging.disable(); // Prevent panning

                const DRAG_THRESHOLD = 5;    // Minimal move detected: 5 pixels
                let startPoint = map.mouseEventToContainerPoint(e);
                let isDragging = false;
                
                const iRef = stages.indexOf(stageRef);  // Retrieve stage index
                if (iRef === -1) return;
                const jRef = stageRef.points.indexOf(pointRef); // Retrieve point index
                if (jRef === -1) return;

                const initMarkerLatlng = pointRef.marker.getLatLng();   // Record initial point coordinates
                // Record intial position of the preceding section
                let initPrevPolylineLatlngs = null;
                if (jRef > 0)
                    initPrevPolylineLatlngs = stageRef.sections[jRef - 1].polyline.getLatLngs(); 
                // Record intial position of the following section
                let initNextPolylineLatlngs = null; 
                if (jRef < stageRef.points.length - 1)
                    initNextPolylineLatlngs = stageRef.sections[jRef].polyline.getLatLngs(); 

                const move = ev => {    // Event: mouse cursor moved
                    const p = map.mouseEventToContainerPoint(ev);
                    if (!isDragging && p.distanceTo(startPoint) < DRAG_THRESHOLD) {
                        return;     // Moved distance too small: still regarded as a click
                    }

                    if (!isDragging) {
                        isDragging = true;  // Register dragging in process
                        context.suppressNextClick = true;
                    
                        map.dragging.disable();
                    }

                    // Prevent event propagation to map
                    L.DomEvent.stopPropagation(ev);
                    L.DomEvent.preventDefault(ev);

                    // Assign new position to point
                    pointRef.marker.setLatLng(ev.latlng);
                    // Replace preceding section with straight dashed line
                    if (stageRef.sections && stageRef.sections[jRef - 1])
                        stageRef.sections[jRef - 1].polyline.setLatLngs(
                            [stage.points[jRef - 1].marker.getLatLng(), ev.latlng])
                            .setStyle({ dashArray: '5, 10' });
                    // Replace preceding section with straight dashed line
                    if (stageRef.sections && stageRef.sections[jRef]) 
                        stageRef.sections[jRef].polyline.setLatLngs([ev.latlng, 
                            stage.points[jRef + 1].marker.getLatLng()])
                            .setStyle({ dashArray: '5, 10' });
                };

                const up = async ev => {    // Event: mouse button up
                    if (!isDragging) {
                        cleanupDrag();
                        return;
                    }

                    // Prevent event propagation to map
                    L.DomEvent.stopPropagation(ev);
                    L.DomEvent.preventDefault(ev);

                    let latlng = map.mouseEventToLatLng(ev);

                    if (jRef > 0 && jRef < stageRef.points.length - 1) {     // Not the first nor le last point 
                        let calculatedPoints1 = null;
                        let calculatedPoints2 = null;
                        if (context.routerProfile) {    // When BRouter used to find a route
                            const pointBeforeLatlng = stageRef.points[jRef - 1].marker.getLatLng();     // Retrieve coordinates of preceding point
                            const pointAfterLatlng = stageRef.points[jRef + 1].marker.getLatLng();      // Retrieve coordinates of following point
                            const coordinates = pointBeforeLatlng.lng + "," +       // Prépare request for BRouter
                                pointBeforeLatlng.lat + "|" + latlng.lng + "," + latlng.lat + "|" + 
                                pointAfterLatlng.lng + "," + pointAfterLatlng.lat;
                            let calculatedPoints = await fetchBRouterRoute(coordinates);    // Query BRouter for a route
                            if (!calculatedPoints) {    // When no route is found by BRouter
                                //alert(context.language === 'EN' ? "Failed to find a path to this location" : "Aucun chemin trouvé pour ce lieu");
                                // Restore initial point and sections
                                pointRef.marker.setLatLng(initMarkerLatlng);
                                stageRef.sections[jRef - 1].polyline.setLatLngs(initPrevPolylineLatlngs)
                                    .setStyle({ dashArray: null });
                                stageRef.sections[jRef].polyline.setLatLngs(initNextPolylineLatlngs)
                                    .setStyle({ dashArray: null });
                                cleanupDrag();
                                return;
                            }
                            // Find the section's point closest to the dragged point
                            const closestSegAndPt = findClosestSectionAndPoint(calculatedPoints, latlng);
                            const idx = closestSegAndPt.index;
                            const closestPt = closestSegAndPt.point;
                            // Prepare set of points to build section before the dragged point
                            calculatedPoints1 = calculatedPoints.slice(0, idx + 1);
                            calculatedPoints1.push(closestPt);
                            calculatedPoints1 = simplifyPolyGeom(calculatedPoints1);    // Simplify the sections geometry by getting rid of part of the points
                            // Prepare set of points to build section after the dragged point
                            calculatedPoints2 = [closestPt].concat(calculatedPoints.slice(idx + 1));
                            calculatedPoints2 = simplifyPolyGeom(calculatedPoints2);   // Simplify the sections geometry by getting rid of part of the points
                            latlng = closestPt;     // Replace the coordinates of the dragged point with those of the closest point
        
                            // Adjust previous point's and previous section's positions
                            const latlng0 = calculatedPoints1[0];
                            stageRef.points[jRef - 1].marker.setLatLng(latlng0);
                            if (stageRef.sections[jRef - 2]) {
                                let latlngs = stageRef.sections[jRef - 2].polyline.getLatLngs()
                                latlngs.pop();
                                latlngs.push(latlng0);
                                stageRef.sections[jRef - 2].polyline.setLatLngs(latlngs);
                            }
                            // Adjust next point's and next section's positions
                            const latlngx = calculatedPoints2[calculatedPoints2.length - 1];
                            stageRef.points[jRef + 1].marker.setLatLng(latlngx);
                            if (stageRef.sections[jRef + 1]) {
                                let latlngs = stageRef.sections[jRef + 1].polyline.getLatLngs()
                                latlngs.shift();
                                latlngs = [latlngx].concat(latlngs);
                                stageRef.sections[jRef + 1].polyline.setLatLngs(latlngs);
                            }
                        } else {    // When BRouter is not used
                            calculatedPoints1 = [stageRef.points[jRef - 1].marker.getLatLng(), latlng];     // Set of points to build the prededing section
                            calculatedPoints2 = [latlng, stageRef.points[jRef + 1].marker.getLatLng()];     // Set of points to build the following section
                        }

                        // Update stage distance
                        stageRef.distance = stageRef.distance
                            - calculateDistance(initPrevPolylineLatlngs)
                            - calculateDistance(initNextPolylineLatlngs)
                            + calculateDistance(calculatedPoints1)
                            + calculateDistance(calculatedPoints2);

                        // Update dragged point and preceding and following sections
                        stageRef.sections[jRef - 1].polyline.setLatLngs(calculatedPoints1)
                            .setStyle({ dashArray: null });                        
                        stageRef.sections[jRef].polyline.setLatLngs(calculatedPoints2)
                            .setStyle({ dashArray: null });
                        pointRef.marker.setLatLng(latlng);
                    } else if (jRef === 0 && stageRef.points.length > 1) {     // First point of several
                        let calculatedPoints = null;
                        if (context.routerProfile) {    // When BRouter is used to find a route
                            const pointAfterLatlng = stageRef.points[1].marker.getLatLng();     // Retrieve next point coordinates
                            const coordinates = latlng.lng + "," + latlng.lat + "|" +   // Prepare request for BRouter
                                pointAfterLatlng.lng + "," + pointAfterLatlng.lat;
                            calculatedPoints = await fetchBRouterRoute(coordinates);    // Query BRouter for a route
                            if (!calculatedPoints) {    // When no route was found by BRouter
                                //alert(context.language === 'EN' ? "Failed to find a path to this location" : "Aucun chemin trouvé pour ce lieu");
                                // Restore initial point and section
                                pointRef.marker.setLatLng(initMarkerLatlng);
                                stageRef.sections[0].polyline.setLatLngs(initNextPolylineLatlngs)
                                    .setStyle({ dashArray: null });
                                cleanupDrag();
                                return;
                            }
                            calculatedPoints = simplifyPolyGeom(calculatedPoints);   // Simplify the sections geometry by getting rid of part of the points
                            latlng = calculatedPoints[0];

                            // Adjust next point's and next section's positions
                            const latlngx = calculatedPoints[calculatedPoints.length - 1];
                            stageRef.points[1].marker.setLatLng(latlngx);
                            if (stageRef.sections[1]) {
                                let latlngs = stageRef.sections[1].polyline.getLatLngs()
                                latlngs.shift();
                                latlngs = [latlngx].concat(latlngs);
                                stageRef.sections[1].polyline.setLatLngs(latlngs);
                            }
                        } else {    // When BRouter is not used
                            calculatedPoints = [latlng, stageRef.points[1].marker.getLatLng()];
                        }

                        // Update stage distance
                        stageRef.distance = stageRef.distance
                            - calculateDistance(initNextPolylineLatlngs)
                            + calculateDistance(calculatedPoints);

                        // Update dragged point and following section
                        stageRef.sections[0].polyline.setLatLngs(calculatedPoints)
                            .setStyle({ dashArray: null });    
                        pointRef.marker.setLatLng(latlng);
                    } else if (stageRef.points.length > 1) {       // Last point or several
                        let calculatedPoints = null;
                        if (context.routerProfile) {
                            const pointBeforeLatlng = stageRef.points[jRef - 1].marker.getLatLng(); // Retrieve preceding point
                            const coordinates = pointBeforeLatlng.lng + "," +       // Prepare request for BRouter
                                pointBeforeLatlng.lat + "|" + latlng.lng + "," + latlng.lat;
                            calculatedPoints = await fetchBRouterRoute(coordinates);    // Query BRouter for a route
                            if (!calculatedPoints) {    // When no route is found by BRouter
                                //alert(context.language === 'EN' ? "Failed to find a path to this location" : "Aucun chemin trouvé pour ce lieu");
                                // Restore initial section and point
                                pointRef.marker.setLatLng(initMarkerLatlng);
                                stageRef.sections[jRef - 1].polyline
                                    .setLatLngs(initPrevPolylineLatlngs)
                                    .setStyle({ dashArray: null });
                                cleanupDrag();
                                return;
                            }
                            calculatedPoints = simplifyPolyGeom(calculatedPoints);   // Simplify the sections geometry by getting rid of part of the points
                            latlng = calculatedPoints[calculatedPoints.length - 1];

                            // Adjust previous point's and previous section's positions
                            const latlng0 = calculatedPoints[0];
                            stageRef.points[jRef - 1].marker.setLatLng(latlng0);
                            if (stageRef.sections[jRef - 2]) {
                                let latlngs = stageRef.sections[jRef - 2].polyline.getLatLngs()
                                latlngs.pop();
                                latlngs.push(latlng0);
                                stageRef.sections[jRef - 2].polyline.setLatLngs(latlngs);
                            }
                        } else {    // When BRouter is not used
                            calculatedPoints = [stageRef.points[jRef - 1].marker.getLatLng(), latlng];
                        }

                        // Update stage distance
                        stageRef.distance = stageRef.distance
                            - calculateDistance(initPrevPolylineLatlngs)
                            + calculateDistance(calculatedPoints);

                        // Update dragged point and preceding section
                        stageRef.sections[jRef -1].polyline.setLatLngs(calculatedPoints)
                            .setStyle({ dashArray: null });                        
                        pointRef.marker.setLatLng(latlng);
                    } else {    // First and only point
                        if (context.routerProfile) {    // When BRouter used to find a route
                            const coordinates = latlng.lng + "," + latlng.lat + "|" + latlng.lng + "," + latlng.lat;     // Prepare request for BRouter                          
                            calculatedPoints = await fetchBRouterRoute(coordinates);    // Query BRouter for a route
                            if (!calculatedPoints) {    // When no route was found
                                //alert(context.language === 'EN' ? "Failed to find a path to this location" : "Aucun chemin trouvé pour ce lieu");
                                // Restore initial point
                                pointRef.marker.setLatLng(initMarkerLatlng);
                                cleanupDrag();
                                return;
                            }

                            pointRef.marker.setLatLng(calculatedPoints[0]);     // Update point's position
                        } else {    // When BRouter is not used
                            pointRef.marker.setLatLng(latlng);  // Update point's position
                        }
                    }

                    calculateAscentAndDescent(stageRef);    // Calculate/update stage ascent/descent

                    updateInfoPopup(stageRef, true);  // Update information about the stage to be displayed in popup

                    cleanupDrag();
                };

                // Use DOM events from the map container to ensure firing consistency
                const moveHandler = ev => {
                    const latlng = map.mouseEventToLatLng(ev);
                    move({ latlng });
                };
                const upHandler = up;

                // Function for cleaning up event listeners from document
                const cleanupDrag = () => {
                    document.removeEventListener('mousemove', moveHandler);
                    document.removeEventListener('mouseup', upHandler);
                    map.dragging.enable();
                };

                // Add event listeners to document
                document.addEventListener('mousemove', moveHandler);
                document.addEventListener('mouseup', upHandler);
            };
        })(stage, point);
        point.marker.addEventListener('mousedown', point_mousedown);    // Add event listener to point
        stage.points[j].evtList.push({ target: point.marker, type: 'mousedown', handler: point_mousedown });    // Register event listener
    }

    //-------------------------
    // Reverse stage direction
    //-------------------------
    async function reverseStage() {
        if (context.editedStage === null) return;

        const stage = stages[context.editedStage];

        // Collect stage points coordinates in reverse order
        const latlngs = [];
        stage.points.forEach(point => {
            latlngs.unshift(point.marker.getLatLng());
        });
        if (latlngs.length === 0) return;

        if (context.routerProfile) {    // When BRouter used to find a route
            let coordinates = '';
            latlngs.forEach((latlng, j) => {
                if (j === 0)
                    coordinates = coordinates.concat(latlng.lng + ',' + latlng.lat);
                else
                    coordinates = coordinates.concat('|' + latlng.lng + ',' + latlng.lat);
            });
            let calculatedPoints = await fetchBRouterRoute(coordinates);    // Query BRouter for a route
            if (!calculatedPoints) {    // When no route is found by BRouter
                //alert(context.language === 'EN' ? "Failed to find a path for the reverse direction" : "Aucun chemin trouvé pour la direction inverse");
                return;
            }
            latlngs.forEach((latlng, j) =>{
                // Find the section's point closest to the dragged point
                const closestSegAndPt = findClosestSectionAndPoint(calculatedPoints, latlng);
                const idx = closestSegAndPt.index;
                const closestPt = closestSegAndPt.point;
                // Update stage's points and sections
                if (j > 0) {
                    const calculatedPoints1 = calculatedPoints.slice(0, idx + 1).concat(closestPt);
                    stage.sections[j - 1].polyline.setLatLngs(simplifyPolyGeom(calculatedPoints1));
                }
                stage.points[j].marker.setLatLng(closestPt);
                calculatedPoints = [closestPt].concat(calculatedPoints.slice(idx + 1));                
            });
        } else {    // When BRouter is not used
            latlngs.forEach((latlng, j) =>{
                // Update stage's points and sections
                if (j > 0) stage.sections[j - 1].polyline.setLatLngs([latlngs[j - 1], latlngs[j]]);
                stage.points[j].marker.setLatLng(latlngs[j]);
            });
        }

        stage.distance = calculateStageDistance(stage);

        calculateAscentAndDescent(stage);    // Calculate/update stage ascent/descent

        updateInfoPopup(stage, true);  // Update information about the stage to be displayed in popup
    }

    //---------------------------------
    // Delete first point of the stage
    //---------------------------------
    function deleteFirstPoint() {
        if (context.editedStage === null) return;

        const i = context.editedStage;  // Retrieve stage to be edited
        const stage = stages[i];

        if (stage.points.length > 1) {  // Stage has more than one point
            stage.distance = stage.distance - calculateDistance(stage.sections[0].polyline.getLatLngs());   // Update stage distance

            // Remove event listeners on first point and first section
            for (const { target, type, handler } of stage.sections[0].evtList)
                target.removeEventListener(type, handler);
            for (const { target, type, handler } of stage.points[0].evtList)
                target.removeEventListener(type, handler);

            // Delete first section and first point
            stage.sections[0].polyline.remove();
            stage.sections.shift();
            stage.points[0].marker.remove();
            stage.points.shift();

            //Update next point layout
            if (stage.points.length > 1)
                stage.points[0].marker.setStyle({ radius: markerSize.medium, opacity: 1, fillOpacity: 0, color: routeColors.editDeparture });
            else
                stage.points[0].marker.setStyle({ radius: markerSize.medium, opacity: 1, fillOpacity: 0, color: routeColors.editSingle });

            // Calculate/update stage ascent/descent
            calculateAscentAndDescent(stage);

            // Update information to be displayed about the stage
            updateInfoPopup(stage, true);
        } else {    // Stage has one point only
            // Remove event listners on point
            for (const { target, type, handler } of stage.points[0].evtList)
                target.removeEventListener(type, handler);

            // Delete point
            stage.points[0].marker.remove();
            if (stage.infoPop)
                stage.infoPop.remove();

            stages.splice(i, 1);    // Delete stage

            setEnv4NonEdt(null);     // Exit edit mode

            context.editedStage = null;
        }
    }

    //--------------------------------
    // Delete last point of the stage
    //--------------------------------
    function deleteLastPoint() {
        if (context.editedStage === null) return;

        // Retrieve stage and point to be edited
        const i = context.editedStage;
        const stage = stages[i];
        const j = stage.points.length - 1; 

        if (j > 0) {  // Stage has more than one point
            stage.distance = stage.distance - calculateDistance(stage.sections[j - 1].polyline.getLatLngs());   // Update stage distance

            // Remove event listeners on last point and last section
            for (const { target, type, handler } of stage.sections[j - 1].evtList)
                target.removeEventListener(type, handler);
            for (const { target, type, handler } of stage.points[j].evtList)
                target.removeEventListener(type, handler);

            // Delete last section and last point
            stage.sections[j - 1].polyline.remove();
            stage.sections.pop();
            stage.points[j].marker.remove();
            stage.points.pop();
            
            // Update preceding point layout
            if (j > 1)
                stage.points[j - 1].marker
                    .setStyle({ radius: markerSize.large, opacity: 1, fillOpacity: 0, color: routeColors.editArrival });
            else
                stage.points[0].marker
                    .setStyle({ radius: markerSize.medium, opacity: 1, fillOpacity: 0, color: routeColors.editSingle });

            // Calculate/update stage ascent/descent
            calculateAscentAndDescent(stage);

            // Update information to be displayed about the stage
            updateInfoPopup(stage, true);
        } else {  // Stage has one single point
            // Remove event listeners on the point
            for (const { target, type, handler } of stage.points[0].evtList)
                target.removeEventListener(type, handler);

            // Delete point
            stage.points[0].marker.remove();    
            if (stage.infoPop)
                stage.infoPop.remove();

            stages.splice(i, 1);    // Delete stage

            setEnv4NonEdt(null);     // Exit edit mode

            context.editedStage = null;
        }
    }

    //--------------
    // Delete stage
    //--------------
    function deleteStg(i) {
        if (i === null) return;

        const stage = stages[i];

        // Remove event listeners on all sections and all points
        if (stage.sections) {
            for (const section of stage.sections)
                for (const { target, type, handler } of section.evtList)
                    target.removeEventListener(type, handler);
        }
        for (const point of stage.points)
            for (const { target, type, handler } of point.evtList)
                target.removeEventListener(type, handler);
        
        //Delete all sections and all points
        if (stage.sections) {
            for (const section of stage.sections)
                section.polyline.remove();
        }
        for (const point of stage.points) 
            point.marker.remove();

        if (stage.infoPop)
            stage.infoPop.remove();

        stages.splice(i, 1);    // Delete stage

        setEnv4NonEdt(null);     // Exit edit status

        context.editedStage = null;
    }

    //---------------------------------
    // Reset route (delete all stages)
    //---------------------------------
    function resetRoute() {
        for (let i = stages.length - 1; i >= 0; i--) {
            deleteStg(i);   // Delete stage
        }

        context.editedStage = null;

        setEnv4NonEdt();     // Exit edit status (if necessary)
    }

    //-----------------------
    // Set/change stage name
    //-----------------------
    function setStgName() {
        if (context.operationWithButtonInProcess)
            return;     // One operation at a time only

        // Create wrapper div
        const wrapper = document.createElement('div');
        wrapper.id = 'gpx-file-wrapper';
        wrapper.style.border = '1px solid #ccc';
        wrapper.style.padding = '8px';
        wrapper.style.marginTop = '8px';

        // Create label
        const label = document.createElement('span');
        label.textContent = context.language === 'EN' ? 'Enter stage\'s name: ' : 'Entrer le nom de l\'étape :';
        wrapper.appendChild(label);

        // Create file input
        const stage = stages[context.editedStage];
        const input = document.createElement('input');
        input.type = 'text';
        input.style.marginLeft = '15px';
        input.size = 100;
        if (stage.name) {
            input.value = stage.name;
        } else {
            input.value = '';
        }
        wrapper.appendChild(input);

        // Add status span
        const status = document.createElement('span');
        status.style.marginLeft = '8px';
        wrapper.appendChild(status);

        // Create submit button
        const button = document.createElement('button');
        button.textContent = 'Set';
        button.style.marginLeft = '8px';
        wrapper.appendChild(button);

        // Escape key handler just for this wrapper
        function escKeyHandler(e) {
            if ((e.key || '').toLowerCase() === 'escape') {
                // Remove wrapper from DOM
                wrapper.remove();
                // Remove this ESC listener
                document.removeEventListener('keydown', escKeyHandler);

                context.operationWithButtonInProcess = false;   // Stop blocking the other operations
            }
        }
        document.addEventListener('keydown', escKeyHandler);
        
        // Process the entered name
        function applyName(name) {
            stage.name = name;

            status.textContent = context.language === 'EN' ? 'Name set' : 'Nom attribué';

            // Close the small UI:
            button.removeEventListener('click', submitHandler);
            input.removeEventListener('keydown', keydownHandler);
            wrapper.remove();
            document.removeEventListener('keydown', escKeyHandler);
            context.operationWithButtonInProcess = false;   // Stop blocking the other operations

            // Update information popup
            updateInfoPopup(stage, true);
            if (context.displayInfo) {
                showInfoPopup(stage);
            }
        }

        // Submit handler (button or Enter)
        function submitHandler() {
            const value = input.value.trim();
            if (!value) {
                applyName(null);
            }
            applyName(value);
        }
        button.addEventListener('click', submitHandler);

        // Keydown handler
        function keydownHandler(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                submitHandler();
            }
        }
        input.addEventListener('keydown', keydownHandler);
                    
        // Finally, add the wrapper to the page
        document.body.appendChild(wrapper);

        // Focus after DOM insertion (and after current event loop)
        setTimeout(() => {
            input.focus();
        }, 0);

        // Register operation in process (to block other potential concurrent operations)
        context.operationWithButtonInProcess = true;
    }

    //----------------------------
    // Create geolocation control
    //----------------------------
    function setGeolocator() {
        if (context.geolocControl) context.geolocControl.remove();  // Remove previous geolocalizer control

        context.geolocControl = L.control({ position: 'topleft' });     // Create new geolocalizer control

        context.geolocControl.onAdd = function () {
            // Create wrapper (that will contain all objects)
            const wrapper = L.DomUtil.create('div', 'leaflet-bar geoloc-btn');
            wrapper.style.background = 'white'; wrapper.href = '#';
            wrapper.style.padding = '8px';
            wrapper.style.display = 'flex';
            wrapper.style.flexDirection = 'column';
            wrapper.style.gap = '8px';
            wrapper.style.minWidth = '130px';
            wrapper.style.maxWidth = '225px';

            // Prevent click propagation to map
            L.DomEvent.disableClickPropagation(wrapper);
            L.DomEvent.on(wrapper, 'click', L.DomEvent.stop);

            // Create title
            const title = L.DomUtil.create('div', 'menu-title', wrapper);
            title.textContent = context.language === 'EN' ? 'Where am I?' : 'Où suis-je ?';
            title.style.fontSize = '16px';
            title.style.fontWeight = 'bold';
            title.style.marginBottom = '4px';

            // Create submit button
            const submitButton = document.createElement('button');
            submitButton.textContent = context.language === 'EN' ? 'Geolocalize me!' : 'Géolocalise-moi !';
            submitButton.style.width = '120px';
            wrapper.appendChild(submitButton);

            // Define submit handler (button)
            async function submitHandler() {
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(setPositionOnMap, handleGeolocationError);
                } else {
                    alert(context.language === 'EN' ? "Geolocation is not supported by this browser." : "La géolocalisation n'est pas supportée par ce navigateur.");
                    return;
                }
            }
            submitButton.addEventListener('click', submitHandler);  // Associate submit handler with button

            //-------------------------------------------------------------
            // Create create two circles on map at the geolocated position
            //-------------------------------------------------------------
            function setPositionOnMap(position) {
                const lat = position.coords.latitude;
                const lng = position.coords.longitude

                map.setView([lat, lng], 15, { 'animate': false });  // Center map on geolocated position
                
                // Remove previous layers if any
                if (window.userLocationMarker) {    
                    map.removeLayer(window.userLocationMarker);
                }
                if (window.userAccuracyCircle) {
                    map.removeLayer(window.userAccuracyCircle);
                }

                // Add small filled black circle to the map at user's position
                window.userLocationMarker = L.circleMarker([lat, lng], {
                    radius: 5,
                    fillColor: 'red',
                    fillOpacity: 1,
                    color: 'red',
                    interactive: false
                }).addTo(map);

                // Add larger accuracy circle
                window.userAccuracyCircle = L.circleMarker([lat, lng], {
                    radius: 12,
                    color: 'red',
                    fillOpacity: 0,
                    weight: 2,
                    interactive: false
                }).addTo(map);
            }  

            //-------------------------------------------------
            // Display an alert message when geolocation fails
            //-------------------------------------------------
            function handleGeolocationError(error) {
                if (error.code === 1)
                    alert(context.language === 'EN' ? 'Permission denied by user' : 'Permission refusée par l\'utilisateur');
                else if (error.code === 2)
                    alert(context.language === 'EN' ? 'Position not available' : 'Position non disponible');
                else if (error.code === 3)
                    alert(context.language === 'EN' ? 'Timeout exceeded' : 'Délai dépassé');
                else    
                    alert(context.language === 'EN' ? 'Unknown error' : 'Erreur inconnue')
            }  

            return wrapper;
        };

        context.geolocControl.addTo(map);       // Add geolocation control to map
        
        const corner = map._controlCorners.topleft;     // Retrieve map corner
        const zoom = map.zoomControl._container;    // Retrieve map zoom control

        // Create a horizontal wrapper only once in order to add the geolocation control beside the zoom control
        let row = corner.querySelector('.leaflet-control-row');
        if (!row) {
            row = L.DomUtil.create('div', 'leaflet-control-row', corner);
            row.style.display = 'flex';
            row.style.alignItems = 'flex-start';
            row.style.gap = '4px';

            corner.insertBefore(row, zoom);
            row.appendChild(zoom);  // Add zoom control to row
        }

        row.appendChild(context.geolocControl._container);  // Add geolocation control to row 
    }

    //--------------------------------
    // Create location finder control
    //--------------------------------
    function setLocationFinder() {
        if (context.locFinderControl) context.locFinderControl.remove();    // Remove previous location finder control

        for (const { target, type, handler } of docLocFindEvtList)  // Remove event listeners associated with the location finder control
            target.removeEventListener(type, handler);
        docLocFindEvtList.splice(0);  // Clear registered event listeners

        context.locFinderControl = L.control({ position: 'topleft' });  // Create new location finder control

        context.locFinderControl.onAdd = function () {      // Set content into location finder control
            // Create white box hosting the content
            const wrapper = L.DomUtil.create('div', 'leaflet-bar unified-control');
            wrapper.style.background = 'white';
            wrapper.style.padding = '8px';
            wrapper.style.display = 'flex';
            wrapper.style.flexDirection = 'column';
            wrapper.style.gap = '8px';
            wrapper.style.minWidth = '150px';
            wrapper.style.maxWidth = '225px';

            // Prevent map interaction
            L.DomEvent.disableClickPropagation(wrapper);
            L.DomEvent.disableScrollPropagation(wrapper);

            // Create title
            const title = L.DomUtil.create('div', 'menu-title', wrapper);
            title.textContent = context.language === 'EN' ? 'Search location' : 'Recherchez un lieu';
            title.style.fontSize = '16px';
            title.style.fontWeight = 'bold';
            title.style.marginBottom = '4px';

            // Create row for hosting label and two buttons
            const row = document.createElement('div');
            row.style.display = 'flex';
            row.style.alignItems = 'center';
            row.style.gap = '6px';
            row.style.justifyContent = 'space-between';
            row.style.width = '100%';

            // Create label
            const label = document.createElement('span');
            label.textContent = context.language === 'EN' ? 'Address:' : 'Adresse :';
            row.appendChild(label);

            // Create submit button
            const submitButton = document.createElement('button');
            submitButton.textContent = context.language === 'EN' ? 'Search' : 'Rechercher';
            submitButton.style.width = '80px';
            row.appendChild(submitButton);

            // Create reset button
            const resetButton = document.createElement('button');
            resetButton.textContent = context.language === 'EN' ? 'Reset' : 'Réinitial.';
            resetButton.style.width = '80px';
            row.appendChild(resetButton);

            // Add label and buttons to row and row to wrapper
            row.appendChild(label);
            row.appendChild(submitButton);
            row.appendChild(resetButton);
            wrapper.appendChild(row);

            // Create text input
            const input = document.createElement('input');
            input.type = 'text';
            input.size = 30;
            wrapper.appendChild(input);

            // Define reset handler (button or Escape)
            async function resetHandler() {
                let container = wrapper.querySelector('#search-results');   // Search for the places found container (if any)
                if (container) 
                    container.remove(); // Remove the results
                input.value = '';   // Clear the input field
                if (window.searchMarker) 
                    window.searchMarker.remove();   // Remove the marker identifying a place found from the map
                if (window.searchPolygon) 
                    window.searchPolygon.remove();  // Remove the polygon identifying an area found from the map
                for (const { target, type, handler } of docLocFindEvtList)
                    target.removeEventListener(type, handler);  // Remove all event listeners associated with places found
                docLocFindEvtList.splice(0);  // Clear registered event listeners
            }
            resetButton.addEventListener('click', resetHandler);    // Associate reset handler with reset button
                    
            // Submit handler (button or Enter)
            async function submitHandler() {
                for (const { target, type, handler } of docLocFindEvtList)  // Remove events listeners associated with places found
                    target.removeEventListener(type, handler);
                docLocFindEvtList.splice(0);  // Clear registered event listeners

                const value = input.value.trim();   // Retrieve content of input field (location address)
                let locs = [];
                if (value) {
                    locs = await fetchCoordinatesWithNominatim(value);  // Retrieve coordinates matching the location address using Nominatim

                    let container = wrapper.querySelector('#search-results');

                    if (!container) {
                        // Create results container if it does not exist
                        container = document.createElement('div');
                        container.id = 'search-results';
                        container.style.maxHeight = '600px';   // adjust as needed
                        container.style.overflowY = 'auto';
                        container.style.overflowX = 'hidden';
                        wrapper.appendChild(container);

                        // Disable event propagation
                        L.DomEvent.disableClickPropagation(container);
                        L.DomEvent.disableScrollPropagation(container);
                        L.DomEvent.on(container, 'mousedown', L.DomEvent.stop);
                    } else {
                        // Clear results container it it exists
                        container.innerHTML = '';
                    }

                    const items = [];
                    let selectedIndex = -1;

                    // Iterate on location found by Nominatim
                    if (locs != null) {
                        locs.forEach((loc, index) => {
                            // Add the location name in the location finder control
                            const div = document.createElement('div');
                            div.className = 'location-item';
                            div.innerHTML = splitByLengthAtSpaces(loc[1], 30);
                            items.push({ div, loc });

                            if (index === 0) {      // First item is selected by default
                                selectItem(0);
                            }

                            L.DomEvent.on(div, 'click', (e) => {    // Define click event handler
                                L.DomEvent.stop(e);     // Stop map interaction

                                selectItem(index);  // Register the selected location item
                            });

                            container.appendChild(div);
                        });
                    }

                    // Escape, arrow down and arrow up keys handler just for this wrapper
                    function keydownDocHandler(e) {
                        if ((e.key || '').toLowerCase() === 'escape') {
                            L.DomEvent.stop(e);     // Stop map interaction
                            
                            resetHandler();     // Clear results (locations found), input field and marker & polygon on the map
                        }

                        if (e.key === "ArrowDown" && items.length) {
                            L.DomEvent.stop(e);     // Stop map interaction

                            selectItem(selectedIndex + 1);  // Register next item as selected
                        }

                        if (e.key === "ArrowUp" && items.length) {
                            L.DomEvent.stop(e);     // Stop map interaction

                            selectItem(selectedIndex - 1);  // Register previous item as selected
                        }
                    }
                    document.addEventListener('keydown', keydownDocHandler);    // Associate event listener with document
                    docLocFindEvtList.push({ target: document, type: 'keydown', handler: keydownDocHandler });  // Register event listener                    
                    
                    // When a result (found location) is selected, register it and display its position on the map
                    function selectItem(index) {
                        if (index < 0 || index >= items.length) return;

                        if (selectedIndex != -1)
                            items[selectedIndex].div.classList.remove('selected');
    
                        selectedIndex = index;  // Register selected location

                        const { div, loc } = items[index];

                        div.classList.add('selected');
            
                        onLocationSelected(loc);    // Display the selected location on the map

                        // Ensure visibility
                        div.scrollIntoView({
                            block: 'nearest',
                            behavior: 'smooth'
                        });
                    }

                    // Display the position of a location found on the map
                    function onLocationSelected(loc) {
                        const [lat, lng] = loc[0];

                        map.setView([lat, lng], 15, { 'animate': false });      // Center the map on the location

                        // Add marker
                        if (window.searchMarker)
                            map.removeLayer(window.searchMarker);       // Remove marker for previous position (if any)

                        window.searchMarker = L.marker([lat, lng], {interactive: false}).addTo(map);    // Add new marker at the location

                        if (window.searchPolygon)
                            map.removeLayer(window.searchPolygon);      // Remove polygon for previous area (if any)

                        if (loc[2] != null) {       // Add new polygon around the location (if area information provided by Nominatim)
                            window.searchPolygon = L.geoJSON(loc[2], {
                                style: {
                                    color: 'blue', 
                                    weight: 2
                                },
                                interactive: false
                            }).addTo(map);

                            map.fitBounds(window.searchPolygon.getBounds());    // Adjust the map zoom level for the polygon
                        }
                    }
                }
            }
            submitButton.addEventListener('click', submitHandler);  // Associate the submit handler with the submit button

            // Keydown handler (another way to submit the location search)
            function keydownInputHandler(e) {
                if (e.key === 'Enter') {
                    L.DomEvent.stop(e);
                    submitHandler();
                }
            }
            input.addEventListener('keydown', keydownInputHandler);
                    
            return wrapper;
        };

        context.locFinderControl.addTo(map);     // Add menu control to map

        // Split an address returned by Nominatim into 30 character lines
        function splitByLengthAtSpaces(str, maxLen = 30) {
            const words = str.split(' ');
            let lines = '';
            let current = '';

            for (const word of words) {
                // If adding the word would exceed the limit
                if ((current + ' ' + word).trim().length > maxLen) {
                    lines = lines.length > 0 ? lines.concat('<br>' + current) : lines.concat(current);
                    current = word;
                } else {
                    current = current ? current + ' ' + word : word;
                }
            }

            if (current) {
                    lines = lines.length > 0 ? lines.concat('<br>' + current) : lines.concat(current);
            }

            return lines;
        }
    }

    //-------------------
    // Save route to GPX
    //-------------------
    function exportRouteToGPX() {
        if (context.operationWithButtonInProcess)
            return;     // One operation at a time only

        // Create a new file by downloading it
        const blob = new Blob([makeGPX("GPX Route Planner export")], { type: "application/gpx+xml" });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = "GPX_Route_Planner_export.gpx";    // Set filename
        a.click();
        URL.revokeObjectURL(a.href);
        console.log(context.language === 'EN' ? "Route exported as GPX file (in default download directory)" : 
            "Itinéraire exporté sous forme de fichier GPX (dans le répertoire de téléchargement par défaut)");

        //----------------------
        // Generate GPX content
        //----------------------
        function makeGPX(name) {
            // Create header
            const header = `<?xml version="1.0" encoding="UTF-8"?>` +
                `\n<gpx version="1.1" creator="RoutePlanner"` +
                `\n    xmlns="http://www.topografix.com/GPX/1/1"` +
                `\n    xmlns:rp="${RP_NS}">` +
                `\n    <metadata>` +
                `\n        <name>${name}</name>` +
                `\n    </metadata>`;
                    
            // Create body
            let body = ``;
            for (let stage of stages) {
                body = body + `\n        <trk>`;    // Create new track
                if (stage.name && stage.name.length > 0)
                    body = body + `\n            <name>"${stage.name}"</name>`;     // Add name
                if (stage.distance != null && stage.ascent != null && stage.descent != null) {
                    // Add distance, ascent, descent as extensions
                    body = body + `\n            <extensions>`;
                    if (stage.distance != null)
                        body = body + `\n                <rp:distance>${stage.distance.toFixed(3)}</rp:distance>`;
                    if (stage.ascent != null)
                        body = body + `\n                <rp:ascent>${stage.ascent.toFixed(3)}</rp:ascent>`;
                    if (stage.descent != null)
                        body = body + `\n                <rp:descent>${stage.descent.toFixed(3)}</rp:descent>`;
                    body = body + `\n            </extensions>`;
                }

                body = body + `\n            <trkseg>`;     // Create new track section          
                for (let i = 0; i < stage.points.length; i++) {
                    const point = stage.points[i];
                    body = body + `\n                <trkpt lat="${point.marker.getLatLng().lat}" lon="${point.marker.getLatLng().lng}">`;  // Add track point with coordinates
                    if (point.marker.getLatLng().alt)
                        body = body + `\n                    <ele>${point.marker.getLatLng().alt}</ele>`;   // Add track point altitude
                    body = body + `\n                </trkpt>`;
                    if (stage.sections[i] && stage.sections[i].polyline.getLatLngs().length > 2) {  // If next section was calculated using BRouter
                        const latlngs = stage.sections[i].polyline.getLatLngs();
                        for (let j = 1; j < latlngs.length - 1; j++) {  // First point is skipped because already added
                            body = body + `\n                <trkpt lat="${latlngs[j].lat}" lon="${latlngs[j].lng}">`;  // Add track point with coordinates
                            if (latlngs[j].alt)
                                body = body + `\n                    <ele>${latlngs[j].alt}</ele>`;     // Add track point altitude
                            // Add source as extension
                            body = body + `\n                    <extensions>`;
                            body = body + `\n                        <rp:source>brouter</rp:source>`;
                            body = body + `\n                    </extensions>`;
                            body = body + `\n                </trkpt>`;
                        }
                    }
                }
                body = body + `\n            </trkseg>`;    // FInish track section
                body = body + `\n        </trk>`;   // Finish track
            }

            const footer = `\n</gpx>`;  // Create footer

            return header + body + footer;  // Merger header, body and footer
        }
    }

    //--------------------------
    // Load route from GXP file
    //--------------------------
    function importRouteFromGPX() {
        if (context.operationWithButtonInProcess)
            return;     // One operation at a time only

        // Create wrapper division
        const wrapper = document.createElement('div');
        wrapper.id = 'gpx-file-wrapper';
        wrapper.style.border = '1px solid #ccc';
        wrapper.style.padding = '8px';
        wrapper.style.marginTop = '8px';

        // Create label
        const label = document.createElement('span');
        label.textContent = context.language === 'EN' ? 'Choose file to be loaded: ' : 'Choisissez le fichier à importer : ';
        wrapper.appendChild(label);

        // Create file input
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.gpx'; // adapt as you like
        wrapper.appendChild(input);

        // Add a small status span
        const status = document.createElement('span');
        status.style.marginLeft = '8px';
        wrapper.appendChild(status);

        // Escape key handler just for this wrapper
        function escKeyHandler(e) {
            if ((e.key || '').toLowerCase() === 'escape') {
                // Remove wrapper from DOM
                wrapper.remove();
                // Remove this ESC listener
                document.removeEventListener('keydown', escKeyHandler);

                context.operationWithButtonInProcess = false;
            }
        }
        document.addEventListener('keydown', escKeyHandler);        // When a file is chosen, read it then remove the wrapper div
        
        // Handler triggered when a file has been selected
        async function changeHandler(e) {
            const file = e.target.files[0];
            if (!file) return;

            try {
                status.textContent = context.language === 'EN' ? 'Reading...' : 'Lecture en cours...';
                const text = await file.text();  // Read file content

                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(text, "application/xml"); // XML parse file content

                // Basic error check
                const parserError = xmlDoc.querySelector("parsererror");
                if (parserError) {
                    console.error(context.language === 'EN' ? "Error parsing GPX:" : "Erreur de parsing du fichier GPX : ", parserError.textContent);
                    status.textContent = context.language === 'EN' ? 'Error parsing GPX' : 'Erreur de parsing GPX';
                    return;
                }

                const trks = Array.from(xmlDoc.querySelectorAll("trk"));    // Retrieve tracks
                trks.forEach(trk => {
                    // Register track as stage
                    stages.push({
                        name: null,
                        sections: [],
                        distance: null,
                        points: [],
                        ascent: null,
                        descent: null,
                        infoPop: null
                    });
                
                    const stage = stages[stages.length - 1];

                    // Retrieve track name and set it as stage name
                    const names = trk.getElementsByTagName("name");
                    if (names.length > 0 && names[0].textContent.length > 0)
                        stage.name = names[0].textContent;
                    // Retrieve track distance and set it as stage distance
                    const distances = trk.getElementsByTagNameNS(RP_NS, "distance");
                    if (distances.length > 0)
                        stage.distance = parseFloat(distances[0].textContent);
                    // Retrieve track ascent and set it as stage ascent
                    const ascents = trk.getElementsByTagNameNS(RP_NS, "ascent");
                    if (ascents.length > 0)
                        stage.ascent = parseFloat(ascents[0].textContent);
                    // Retrieve track descent and set it as stage descent
                    const descents = trk.getElementsByTagNameNS(RP_NS, "descent");
                    if (descents.length > 0)
                        stage.descent = parseFloat(descents[0].textContent);
                
                    let polypoints = [];
                    const trksegs = Array.from(trk.querySelectorAll("trkseg"));     // Retrieve track sections
                    trksegs.forEach((trkseg, j) => {
                        const trkpts =  Array.from(trkseg.querySelectorAll("trkpt"));
                        trkpts.forEach((trkpt, k) => {
                            let latlng = null;
                            const eles = Array.from(trkpt.getElementsByTagName("ele"));
                            if (eles.length > 0)
                                latlng = {
                                    lat: parseFloat(trkpt.getAttribute("lat")),
                                    lng: parseFloat(trkpt.getAttribute("lon")),
                                    alt: parseFloat(eles[0].textContent)
                                }
                            else
                                latlng = {
                                    lat: parseFloat(trkpt.getAttribute("lat")),
                                    lng: parseFloat(trkpt.getAttribute("lon"))
                                }
                            if (stage.points.length === 0) {
                                // Register first point of the section and create marker on the map
                                const newCircleMarker = L.circleMarker(latlng, 
                                    { pane: 'markerPaneTop', draggable: true, autoPan: false, bubblingMouseEvents: true })
                                    .addTo(map);
                                stage.points.push({marker: newCircleMarker, evtList: []});
                                polypoints.push(latlng);
                            } else if (isBRouterPoint(trkpt)) { // Register intermediate point calculated by BRouter
                                polypoints.push(latlng);
                            } else {
                                // Register end of section point and create marker and polyline on the map
                                const newCircleMarker = L.circleMarker(latlng, 
                                    { pane: 'markerPaneTop', draggable: true, autoPan: false, bubblingMouseEvents: true })
                                    .addTo(map);
                                stage.points.push({marker: newCircleMarker, evtList: []});
                                polypoints.push(latlng);
                                const newPolyline = L.polyline(polypoints).addTo(map);
                                stage.sections.push({polyline: newPolyline, evtList: []});
                                polypoints = [latlng];
                            }
                        });
                    });
                    // If the last point of the last track was a point calculated by BRouter, the last section has not been imported. Import it properly now.
                    if (polypoints.length > 1) {
                        const latlng = polypoints[polypoints.length - 1];
                        const newCircleMarker = L.circleMarker(latlng, 
                            { pane: 'markerPaneTop', draggable: true, autoPan: false, bubblingMouseEvents: true })
                            .addTo(map);
                        stage.points.push({marker: newCircleMarker, evtList: []});
                        const newPolyline = L.polyline(polypoints).addTo(map);
                        stage.sections.push({polyline: newPolyline, evtList: []});
                    }

                    // Calculate stage distance if not found in GPX file
                    if (stage.distance === null) {
                        let distance = 0;
                        for (let i = 1; i < stage.sections.length; i++) {
                            const points = stage.sections[i].polyline.getLatLngs();
                            distance = distance + calculateDistance(points);
                        }
                        stage.distance = distance;
                    }

                    // Calculate stage ascent and descent if not found in GPX file
                    if (stage.ascent === null || stage.descent === null)
                        calculateAscentAndDescent(stage);

                    updateInfoPopup(stage, false);     // Update information popup
                     
                    const oldEditedStage = context.editedStage;     // Save the stage currently being edited
                    setStg4NonEdt(stages.length - 1);   // Set the just loaded stage to non edit status
                    context.editedStage = oldEditedStage;   // Restore the stage currently being edited

                    console.log(context.language === 'EN' ? "Route imported from GPX file '" : "Itinéraire importé du fichier GPX '" + file.name + "'");
                });
                
                // Remove the whole wrapper div from the DOM
                input.removeEventListener('change', changeHandler);     // Remove event handler
                wrapper.remove();
                 // And remove ESC listener since wrapper is gone
                document.removeEventListener('keydown', escKeyHandler);

                // Focus the map on the route
                let bounds = L.latLngBounds([]);    // Initialize an array of all polyline bounds

                stages.forEach(stage => {   // Store the bounds of all polylines of all stages
                    stage.sections.forEach(section => {
                        bounds.extend(section.polyline.getBounds());
                    });
                });

                if (bounds.isValid()) {
                    map.fitBounds(bounds);  // Focus the map on the polylines
                }

                context.operationWithButtonInProcess = false;   // Stop blocking the other operations
            } catch (err) {     // Error handler
                console.error(context.language === 'EN' ? 'Error reading file:' : 'Erreur de lecture du fichier : ', err);
                status.textContent = context.language === 'EN' ? 'Error reading file' : 'Erreur de lecture du fichier';
            }
        }
        input.addEventListener('change', changeHandler);       // Add event handler to file input

        // Finally, add the wrapper to the page
        document.body.appendChild(wrapper);

        context.operationWithButtonInProcess = true;    // Block other current operations
                            
        //--------------------------------------------------------------------------
        // Check whether the point was created by the user or calculated by BRouter
        //--------------------------------------------------------------------------
        function isBRouterPoint(pt) {

            const sourceEls = pt.getElementsByTagNameNS(RP_NS, "source");
            return sourceEls.length > 0 && sourceEls[0].textContent === "brouter";
        }
    }

    //----------------------------------------------------------------------------------------
    // Calculate stage's ascent and descent with smoothing the elevations returned by BRouter
    //----------------------------------------------------------------------------------------
    function calculateAscentAndDescent(stage) {
        const SMOOTH_WINDOW = 4;    // A sample of n preceding and n following points surrounding the current point will be used to smooth the calculated ascent and descent

        stage.ascent = null;     // Calculated ascent
        stage.descent = null;    // Calculated descent

        let sample = [];    // Array of the altitudes of the points surrounding the current point
        let sampTotal = 0;   // Total of the altitudes of the points in "sample" array
        let sampNotNullNb = 0;      // Nb of not null altitudes in "sample" array
        let prevSmoothAlt = null;     // Smoothed altitude of the preceding point

        let i2 = null;     // Section number of the last point which altitude was added to the sample
        let j2 = null;     // Position in section of the last point which altitude was added to the sample
        let latlngs2 = null;    // Array of altitudes of the section of the last point added to the sample

        for (let i = 0; i < stage.sections.length; i++) {
            let latlngs = stage.sections[i].polyline.getLatLngs();  // Get coordinates (including elevations) of the points of the section
            for (let j = 0; j < latlngs.length; j++) {
                if (sample.length === 0) {      // First point of first section: push null elevations into sample to represent ghost preceding points
                    for (let k = 0; k < SMOOTH_WINDOW; k++)
                        sample.push(null);
                    i2 = i;
                    j2 = j;
                    latlngs2 = latlngs;
                } else {    // Not first point of first section: remove leftest point from sample
                    if (j === 0)
                        continue;   // First point of a section skeeped because the same as last point of the previous section (must not be taken into account twice)
                    if (sample[0] != null) {
                        sampTotal = sampTotal - sample[0];  // Update sum of altitudes for sample
                        sampNotNullNb--;    // Update number of not null altitudes for the sample
                    }
                    sample.shift();     // Remove leftest point from the sample
                }
                for (let k = 0; k < (2 * SMOOTH_WINDOW) + 1 - sample.length; k++) {  // Complete sample with current or following points altitudes
                    j2++;
                    if (j2 < latlngs2.length) {     // End of section not reached
                        if (latlngs2[j2] && latlngs2[j2].alt != null) {     // Point altitude known
                            sample.push(latlngs2[j2].alt);  // Push altitude into sample
                            sampTotal = sampTotal + latlngs2[j2].alt; // Update sum of altitudes for the sample
                            sampNotNullNb++;    // Update number of not null altitudes for the sample
                        } else  // Point altitude unkonwn
                            sample.push(null);
                    } else {    // End of the section reached. Point to be searched in next section
                        i2++;   // Move to next section
                        if (i2 <= stage.sections.length - 1) {  // Not beyond end of sections
                            latlngs2 = stage.sections[i2].polyline.getLatLngs();    // Extract coordinates of section's points
                            j2 = 1;     // Second point (first point skipped because the same as the last point of the previous section)
                            if (latlngs2[j2] && latlngs2[j2].alt != null) {     // Point altitude known
                                sample.push(latlngs2[j2].alt);  // Push altitude into sample
                                sampTotal = sampTotal + latlngs2[j2].alt;   // Update sum of altitudes for the sample
                                sampNotNullNb++;    // Update number of not null altitudes for the sample
                            } else  // Point altitude unknown
                                sample.push(null);
                        } else  // Beyond end of sections: push null elevation for ghost point
                            sample.push(null);
                    }
                }
                let smoothAlt = null;
                if (sampNotNullNb > 0 )
                    smoothAlt = sampTotal / sampNotNullNb;      // Calculate smoothed altitude for the point as the average altitude of the sample
                if (smoothAlt != null && prevSmoothAlt != null) {
                    const diff = smoothAlt - prevSmoothAlt;     // Calculate smoothed altitude difference with the previous point
                    // Initialize ascent and descent if needed
                    if (stage.ascent === null)
                        stage.ascent = 0;
                    if (stage.descent === null)
                        stage.descent = 0;
                    // Update ascent and descent
                    if (diff > 0)
                        stage.ascent = stage.ascent + diff;
                    else
                        stage.descent = stage.descent + diff;
                }
                if (smoothAlt != null)    // Save point smoothed altitude for future use with next point
                    prevSmoothAlt = smoothAlt;
            }
        }
    }

    //------------------------------------------------------------
    // Calculate the length of a stage
    //------------------------------------------------------------
    function calculateStageDistance(stage) {
        let dist = 0;

        stage.sections.forEach(section => {
            dist = dist + calculateDistance(section.polyline.getLatLngs());
        });

        return dist;
    }

    //------------------------------------------------------------
    // Calculate the length of a path defined with several points
    //------------------------------------------------------------
    function calculateDistance(points) { 
        let dist = 0;

        for (let i = 1; i < points.length; i++) {
            dist = dist + haversine(points[i - 1], points[i]);  // Use the haversine function to add the distance between two points
        }
        
        return dist;
    }

    //----------------------------------------------
    // Query BRouter to find a route between points
    //----------------------------------------------
    async function fetchBRouterRoute(coordinates) {
        // Prepare request to BRouter
        const url = "https://brouter.de/brouter?lonlats=" + coordinates +
            "&profile=" + context.routerProfile +"&alternativeidx=0&format=geojson";

        try {
            // Fetch BRouter GeoJSON
            const response = await fetch(url);

            if (!response.ok) {
                if (response.status === 400)
                    throw new Error(context.language === 'EN' ? "Failed to find a path to this location" : "Pas de chemin trouvé pour ce lieu");
                else 
                    throw new Error(context.language === 'EN' ? `HTTP error, status: ${response.status}` : `Erreur HTTP, état: ${response.status}`);
            }

            // Parse JSON
            const geojson = await response.json();

            // Extract coordinates from the first LineString
            const coords = geojson.features[0].geometry.coordinates;

            // Convert to {lat: ..., lng: ..., alt: ...} objects
            return coords.map(([lon, lat, alt]) => ({
                lat: lat,
                lng: lon,
                alt: alt
            }));
        } catch (err) {
            console.error(context.language === 'EN' ? "Error fetching BRouter route: " : "Erreur lors de l'interrogation de BRouter : ", err.message);
            alert(context.language === 'EN' ? "Error fetching BRouter route: " + err.message : "Erreur lors de l\'interrogation de BRouter : " + err.message);
            return null;
        }
    }

    //-----------------------------------------
    // Query Nominatim to geolocate an address
    //-----------------------------------------
    async function fetchCoordinatesWithNominatim(address) {
        // Nominatim's URL
        const url = "https://nominatim.openstreetmap.org/search?q=" + address +
            "&format=json&polygon_geojson=1&dedupe&limit=10";

        try {
            // Fetch Nominatim
            const response = await fetch(url);

            // When Nominatim query failed
            if (!response.ok) {
                throw new Error(context.language === 'EN' ? `HTTP error! Status: ${response.status}` : `Erreur HTTP! Etat : ${response.status}`);
            }

            // Parse JSON
            const respJSON = await response.json();

            if (respJSON.length === 0)
                throw new Error(context.language === 'EN' ? "No location found tor this address: " : "Pas de lieu trouvé pour cette adresse : " + address);

            const respData = []
            respJSON.forEach((item) => {    // Process the locations found by Nominatim
                let polygonJSON = null;
                if (item.geojson.type === 'Polygon' || item.geojson.type === 'MultiPolygon') {  // Did Nominatim return an area for the location?
                    polygonJSON = JSON.parse('{"type": "FeatureCollection", "features": [{"type": "Feature", "properties": {}}]}');
                    polygonJSON.features[0].geometry = item.geojson;
                }

                respData.push([[item.lat, item.lon], item.display_name, polygonJSON]);
            });

            return respData;
        } catch (err) {
            alert(context.language === 'EN' ? "Error fetching coordinates with Nominatim: " + err.message : "Erreur lors de l'interrogation de Nominatim : " + err.message);
            console.error(context.language === 'EN' ? "Error fetching coordinates with Nominatim: " : "Erreur lors de l'interrogation de Monimatim : ", err.message);
            return null;
        }
    }

    //-------------------------------------------------
    // Find closest section part from clicked position
    //-------------------------------------------------
    function findClosestSectionAndPoint(latlngs, clickLatLng) {
        let minDistance = Infinity;
        let closestIdx = -1;

        // Find closest section segment
        for (let i = 0; i < latlngs.length - 1; i++) {
            const segStart = latlngs[i];
            const segEnd = latlngs[i + 1];
        
            // Distance from point to segment
            const distance = L.LineUtil.pointToSegmentDistance(
                map.latLngToLayerPoint(clickLatLng),
                map.latLngToLayerPoint(segStart),
                map.latLngToLayerPoint(segEnd)
            );

            if (distance < minDistance) {
                minDistance = distance;
                closestIdx = i;
            }
        }

        // Find closest point in section part
        const closestPoint = closestPointOnSection(clickLatLng, latlngs[closestIdx], latlngs[closestIdx + 1]);

        return {index: closestIdx, point: closestPoint}; // Index of the section part and closest point

        //------------------------------------------------
        // Function to find closest point on section part
        //------------------------------------------------
        function closestPointOnSection(p, p1, p2) {
            const dLng = p2.lng - p1.lng;
            const dLat = p2.lat - p1.lat;
            const dAlt = p2.alt - p1.alt;

            const l2 = dLng * dLng + dLat * dLat;   // Square of the distance between p1 and p2
            if (l2 === 0) 
                return { lat: p1.lat, lng: p1.lng }; // p1 == p2

            // Projection parameter t (scalar product of two vectors clamped to [0, 1]) - 
            let t = ((p.lng - p1.lng) * dLng + (p.lat - p1.lat) * dLat) / l2;
            t = Math.max(0, Math.min(1, t));

            return {
                lat: p1.lat + t * dLat,
                lng: p1.lng + t * dLng,
                alt: p1.alt + t * dAlt
            };
        }
    }

    //-----------------------------------------------------------------
    // Find medium position on a stage to display information about it
    //-----------------------------------------------------------------
    function findMediumPosition(stage) {
        if (stage.points && stage.points.length > 1) {
            if (stage.points.length % 2 != 0) { // Odd number of points
                const midPtIdx = ~~(stage.points.length / 2);
                return point = stage.points[midPtIdx].marker.getLatLng() ;  // Return point in middle position
            } else {    // Even number of points
                const midSegIdx = ~~(stage.sections.length / 2);
                const pts = stage.sections[midSegIdx].polyline.getLatLngs();
                if (pts.length % 2 === 0) {
                    const midPtIdx = ~~(pts.length / 2) - 1;
                    return {    // Return point in the middle of the section in the middle position
                        lat: (pts[midPtIdx].lat + pts[midPtIdx + 1].lat) / 2, 
                        lng:  (pts[midPtIdx].lng + pts[midPtIdx + 1].lng) / 2
                    }
                } else {
                    const midPtIdx = ~~(pts.length / 2);
                    return pts[midPtIdx];
                }
            }
        } else if (stage.points && stage.points.length === 1)
            return stage.points[0].marker.getLatLng();
        else
            return null;
    }

    //------------------------------------------------------------------------------------------------------
    // Find position in the middle of the last but one section of the stage to display information about it
    //------------------------------------------------------------------------------------------------------
    function findNearbyPosition(stage) {
        if (stage.points && stage.points.length > 2) {
            const pts = stage.sections[stage.sections.length - 2].polyline.getLatLngs();
            if (pts.length % 2 === 0) {
                const midPtIdx = ~~(pts.length / 2) - 1;
                return {    // Return point in the middle of the section in the middle position
                    lat: (pts[midPtIdx].lat + pts[midPtIdx + 1].lat) / 2, 
                    lng:  (pts[midPtIdx].lng + pts[midPtIdx + 1].lng) / 2
                }
            } else {
                const midPtIdx = ~~(pts.length / 2);
                return pts[midPtIdx];
            }
        } else if (stage.points && (stage.points.length === 1 || stage.points.length === 2))
            return stage.points[0].marker.getLatLng();
        else 
            return null;
    }

    //---------------------------------------------------------------
    // Calculate distance between two points using haversine formula 
    //---------------------------------------------------------------
    function haversine(latlng1, latlng2) {
        const R = 6371; // Earth's radius in kilometers
        //const R = 3959; // Earth's radius in miles

        const toRad = angle => angle * Math.PI / 180;

        const dLat = toRad(latlng2.lat - latlng1.lat);
        const dLon = toRad(latlng2.lng - latlng1.lng);

        const phi1 = toRad(latlng1.lat);
        const phi2 = toRad(latlng2.lat);

        const a = Math.sin(dLat / 2) ** 2 +
            Math.cos(phi1) * Math.cos(phi2) *
            Math.sin(dLon / 2) ** 2;

        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

        return R * c;
    }

    //------------------------------------------------------------
    // Display information about stage name and distance as popup
    //------------------------------------------------------------
    function hideInfoPopup(stage) {
        if (stage.infoPop) {
            stage.infoPop.remove();
        }
    }

    //------------------------------------------------------------
    // Display information about stage name and distance as popup
    //------------------------------------------------------------
    function showInfoPopup(stage) {
        if (stage.infoPop) {
            stage.infoPop.addTo(map);
        }
    }

    //---------------------------------------------------------------------------------
    // Simplify the geometry of a section returned by BRouter by decimating the points
    //---------------------------------------------------------------------------------
    function simplifyPolyGeom(latlngs) {
        const SELECT_NB = 2;

        const lastIdx = latlngs.length - 1;
        return latlngs.filter((_, i) => i % SELECT_NB === 0 || i === lastIdx);  // Only points with even index will be kept (plus the last point)
    }

    //-----------------------------------------------------------
    // Update information about stage name and distance as popup
    //-----------------------------------------------------------
    function updateInfoPopup(stage, editMode) {
        let pos = null;
        if (editMode) 
            pos = findNearbyPosition(stage);
        else 
            pos = findMediumPosition(stage);
        if (pos === null) return;

        // Remove previous information popup
        if (stage.infoPop) {
            stage.infoPop.remove();
        }

        // Create popup with information content
        stage.infoPop = L.popup(
            { closeOnClick: false, autoClose: false, autoPan: false, className: 'solid-popup' })
            .setLatLng(pos)
            .setContent(`<div style="text-align:left; font-size:12px; line-height:12px;">${
                stage.name && stage.name.length > 0 
                    ? `<span style="font-size:16px; line-height:24px;"><b>${stage.name}:</b></span><br>` 
                    : ``
            }
            ${
                stage.distance > 0 
                ? `<b>Distance: </b> ${
                    context.metricUnits 
                        ? `${stage.distance.toFixed(3)} km` 
                        : `${(stage.distance/1.609344).toFixed(3)} mi`
                }<br>` 
                : ''
            }
            <b>Altitude: </b> ${
                stage.points[0].marker.getLatLng().alt 
                ? context.metricUnits 
                    ? `${Math.round(stage.points[0].marker.getLatLng().alt)} m` 
                    : `${Math.round(stage.points[0].marker.getLatLng().alt/0.3048)} ft`                 
                : '?'
            }
            ${
                stage.points.length >= 2 
                    ? `<span style="font-size:20px;">&#8594;</span> ${
                        stage.points[stage.points.length - 1].marker.getLatLng().alt 
                        ? context.metricUnits 
                            ? `${Math.round(stage.points[stage.points.length - 1].marker.getLatLng().alt)} m` 
                            : `${Math.round(stage.points[stage.points.length - 1].marker.getLatLng().alt/0.3048)} ft`
                        : '?'
                    }`
                    : ''
            }
            ${
                stage.ascent != null && stage.descent != null 
                    ? `<br><b>${
                        context.language === 'EN' 
                            ? 'Elevation:' 
                            : 'Dénivelé :'
                    }</b> ${
                        stage.ascent != null 
                            ? `<span style="font-size:20px;">&#8593;</span> ${
                                context.metricUnits
                                    ? `${Math.round(stage.ascent)} m`
                                    : `${Math.round(stage.ascent/0.3048)} ft`
                            }` 
                            : ''
                    } ${
                        stage.descent != null 
                            ? ` <span style="font-size:20px;">&#8595;</span> ${
                                context.metricUnits
                                    ? `${Math.round(-stage.descent)} m` 
                                    : `${Math.round(-stage.descent/0.3048)} ft`
                            }`
                            : ''
                    }`
                    : ''
            }
            </div>`);

        // Add popup to map if requested
        if (context.displayInfo)
            stage.infoPop.addTo(map);
    }

    //--------------------------------
    // Prepare help content (english)
    //--------------------------------
    function getHelpContentEn() {
        return (`
<h1>GPX Route Planner</h1>
<p>The purpose of the application is to create walking, cycling, or driving routes by plotting them on a map. The routes created can be exported in GPX format, allowing them to be used next with a GPS or mobile navigation and guidance application.</p>
<p>The application only allows you to create or modify one route at a time. This route consists of:</p>
<ul>
<li>One or more stages. A stage is a journey that you plan to complete in one go or in one day. It consists of:
<ul>
<li>A starting point, an end point, and may also include waypoints.</li>
<li>One or more sections (curved or straight) corresponding to the paths connecting these points.</li>
</ul>
</li>
</ul>
<p>This application was developed entirely with open-source tools and services.</p>
<h2>Maps</h2>
<p>Maps are used to create routes (the route is plotted on the map).</p>
<p>The application offers several map styles:</p>
<ul>
<li>A topographic map (displayed by default) highlighting the natural features of the terrain (relief, waterways, coastlines, etc.) and showing contour lines. </li>
<li>A general map (from OpenStreetMap).</li>
<li>A map with hiking trails (Waymarked Trails - Hiking).</li>
<li>A map with cycling tracks (Waymarked Trails - Cycling).</li>
<li>A map in the form of satellite views.</li> 
</ul>
<p>You can zoom in and out on the maps using the mouse wheel or the + and - controls (displayed at the top left).</p>
<p>You can also move the map in any direction by dragging and dropping.</p>
<h2>Working modes</h2>
<p>The application offers two working modes:</p>
<ul>
<li>The “create/edit stage” mode, which allows you to create a new stage or edit an existing stage of the route.</li>
<li>The “supervision” mode: the stages of the route are displayed, but none are being edited. </li>
</ul>
<p>When you open the application, you are in stage create/edit mode, allowing you to create a first stage by adding points (and sections) to the map using the mouse.</p>
<ul>
<li>To switch to supervision mode, click the "Quit stage edition" button or press the Escape key.</li>
<li>To switch back to create/edit mode, either click the "Start creating new stage" button or double-click on the map (to create a new stage) or double-click on an existing stage (to edit it).</li>
</ul>
<h3>Stage create/edit mode</h3>
<p>This mode allows you to create a new stage or to edit an existing stage of the route. By clicking repeatedly on the map, points are added to the stage, with sections connecting them to the previous points. The other stages are displayed but cannot be modified. This is the default mode when the application is launched (you are supposed to start by creating a stage).</p>
<p>The actions available when creating/editing the stage are:</p>
<ul>
<li>Click on the map to add an additional point to the stage. If other points already exist, a section is also created to connect the previous point to this new point. The path used between these two points is determined by the chosen travel mode:
<ul>
<li>Walking/hiking (default): paths and small roads are preferred. </li>
<li>Mountain biking: paths and trails are preferred. </li>
<li>Road cycling: paved roads are used, excluding highways.</li>
<li>Car route: paved roads and major roads are used.</li>
<li>-- crow --: allows you to plot a straight line between two points, whether or not a path exists.</li>
</ul>
For the first four travel modes, the route is calculated using the BRouter routing service and the resulting paths are curved. For the last one, a straight segment is plotted between the two points.
</li>
<li>Double-click on a section of the stage to insert a new point.</li>
<li>Double-click on a point in the stage to delete it.</li>
<li>Drag and drop a point on the stage to move it.</li>
<li>Drag and drop a section of the stage to insert a new point and move it.</li>
<li>Click the "Set stage name" button or press the “n” key to assign a name to the stage.</li>
<li>Click the "Reverse stage direction" button or press the "r" key to reverse the stage's direction.</li>
<li>Press the “u” key to delete the last point on the stage.</li>
<li>Press the “v” key to delete the first point on the stage.</li>
<li>Click the "Delete stage" button or press the “d” key to delete all points (and all sections) from the stage. This action also switches to supervision mode.</li>
<li>Click the "Quit stage edition" button or press the “Escape” key to finish creating/editing the stage and switch to supervision mode. </li>
<li>Click the "Start creating a new stage" button or double-click on the map to finish creating/editing the current stage and switch to create/edit mode for a new stage. </li>
<li>Double-click on a point or section of another stage to finish creating/editing the current stage and switch to create/edit mode for that stage. </li>
<li>Click the "Import stages from GPX" or press the “i” key to import additional stages from a GPX file (without deleting the stages already defined). </li>
<li>Click the "Export route to GPX" or press the “e” key to export the route to a GPX file. </li>
<li>Click the "Reset route" or press the “z” key to reset the route (i.e., delete all the stages).</li>
</ul>
<h3>Supervision mode</h3>
<p>This mode allows you to view the stages of the route without any being created/edited. The start and end points of each stage are shown, but not the waypoints. </p> 
<p>The available actions are:</p>
<ul>
<li>Click the "Start creating a new stage" button or double-click on the map to switch to create/edit mode for a new stage. </li>
<li>Double-click on a point or section of a stage to switch to create/edit mode for that stage. </li>
<li>Click the "Import stages from GPX" or press the “i” key to import additional stages from a GPX file (without deleting the stages already defined). </li>
<li>Click the "Export route to GPX" or press the “e” key to export the route to a GPX file. </li>
<li>Click the "Reset route" or press the “z” key to reset the route (i.e., delete all the stages).</li>
</ul>
<h2>Miscellaneous</h2>
<p>The user interface language can be selected: English (default) or French.</p>
<p>The measurement units can be chosen using the "Measurement units" radio buttons: metric (default) or imperial.</p>
<p>Information such as the name of the stage, its length, the starting and finishing altitudes, and the positive and negative elevation gains can be displayed or hidden using the "Display stage information" radio buttons.</p>
<p>A geolocation function is provided (top left). It allows you to determine the user's position and center the map on it. The browser's Geolocation API is used for that purpose. </p>
<p>A location search function based on an address is provided (top left). It allows you to search for a location using a more or less detailed address and center the map on it. Several locations matching the search can be found and displayed in a list. The Nominatim geocoding service is used for that purpose.</p>
        `);
    }

    //-------------------------------
    // Prepare help content (french)
    //-------------------------------
    function getHelpContentFr() {
        return (`
<h1>Planificateur d'Itinéraires GPX</h1>
<p>L'objectif de l'application et de créer des itinéraires piétons, cyclistes ou automobile en les traçant sur une carte. Les itinéraires créés peuvent être exportés en format GPX, ce qui permet de les utiliser ensuite avec un GPS ou une application mobile de navigation et de guidage.</p>
<p>L'application ne permet de créer ou modifier qu'un itinéraire à la fois. Cet itinéraire est composé :</p>
<ul>
<li>D'une ou plusieurs étapes. Une étape est un parcours que l'on prévoit de réaliser d'une traite ou en une journée. Elle est composée :
<ul>
<li>D'un point de départ, d'un point d'arrivée et peut comprendre aussi des points de passage.</li>
<li>D'une ou plusieurs sections (courbes ou droites) correspondant aux chemins reliant ces points.</li>
</ul>
</li>
</ul>
<p>Cette application a été entièrement réalisée avec des outils et services open-source.</p>
<h2>Cartes</h2>
<p>Des cartes servent de support à la création d'itinéraires (on trace l'itinéraire sur la carte).</p>
<p>Plusieurs styles de carte sont offerts par l'application :</p>
<ul>
<li>Une carte topographique (présentée par défaut) mettant en évidence les caractéristiques naturelles du terrain (relief, cours d'eau, côtes...) et représentant les courbes de niveau.</li>
<li>Une carte généraliste (celle d'OpenStreetMap).</li>
<li>Une carte avec des sentiers de randonnée (Waymarked Trails - Hiking).</li>
<li>Une carte avec des pistes de cyclotourisme (Waymarked Trails - Cycling).</li>
<li>Une carte sous forme de vues satellite.</li> 
</ul>
<p>On peut zoomer et dézoomer les cartes en utilisant la molette de la souris ou les contrôles + et - (affichés en haut à gauche de la carte).</p>
<p>On peut aussi déplacer la carte dans toutes les directions par tirer-déposer.</p>
<h2>Modes de travail</h2>
<p>L'application offre deux modes de travail :</p>
<ul>
<li>Le mode "création/modification d'étape", permettant de créer une nouvelle étape ou de modifier une étape existante de l'itinéraire.</li>
<li>Le mode "supervision" : les étapes de l'itinéraire sont affichées, mais aucune n'est en cours de modification.</li>
</ul>
<p>En ouvrant l'application, on est en mode création/modification d'étape, afin de créer une première étape en ajoutant des points (et des sections) sur la carte à l'aide de la souris.</p>
<ul>
<li>Pour passer en mode supervision, il faut cliquer le bouton "Quitter édition de l'étape" ou presser la touche Echappement</li>
<li>Pour repasser en mode création/modification, il faut cliquer sur le bouton "Démarrer création nouvelle étape" ou double cliquer sur la carte (pour créer une nouvelle étape), soit double-cliquer sur une étape existante (afin de la modifier).</li>
</ul>
<h3>Mode création/modification d'étape</h3>
<p>Ce mode permet de créer une nouvelle étape ou de modifier une étape existante de l'itinéraire. En cliquant de manière répétée sur la carte, on ajoute des points à l'étape, et des sections les reliant aux points précédents. Les autres étapes sont affichées, mais ne peuvent pas être modifiées. C'est le mode par défaut au lancement de l'application (on est censé commencer par créer une étape).</p>
<p>Les actions disponibles en mode édition/modification d'étape sont :</p>
<ul>
<li>Cliquer sur la carte pour ajouter un point supplémentaire à l'étape. Si d'autres points existent déjà, une section est aussi créée pour relier le point précédent à ce nouveau point. Le chemin utilisé entre ces deux points est déterminé par le mode de voyage choisi :
<ul>
<li>Marche/randonnée (par défaut) : les chemins et les petites routes sont choisis de préférence.</li>
<li>VTT : les chemins et sentiers sont choisis de préférence.</li>
<li>Cyclisme sur route : les routes goudronnées sont utilisées, à l'exclusion des autoroutes.</li>
<li>Automobile : les routes goudronnées et les grands axes sont utilisés.</li>
<li>Aucun : permet de tracer un trajet en ligne droite entre deux points, qu'il existe ou non un chemin.</li>
</ul>
Pour les quatre premiers modes de voyage, le parcours est calculé à l'aide du service de routage BRouter etles chemins résultants sont courbes. Pour le dernier, un segment de droite est tracé entre les deux points.
</li>
<li>Double-cliquer sur une section de l'étape pour insérer un nouveau point.</li>
<li>Double-cliquer sur un point de l'étape pour le supprimer.</li>
<li>Tirer-déposer un point de l'étape pour le déplacer.</li>
<li>Tirer-déposer une section de l'étape pour insérer un nouveau point et le déplacer.</li>
<li>Cliquer sur le bouton "Attribuer nom à l'étape" ou presser la touche "n" pour attribuer un nom à l'étape.</li>
<li>Cliquer sur le bouton "Inverser direction de l'étape" ou presser la touche "r" pour inverser la direction de l'étape.</li>
<li>Presser la touche "u" pour supprimer le dernier point de l'étape.</li>
<li>Presser la touche "v" pour supprimer le premier point de l'étape.</li>
<li>Cliquer sur le bouton "Supprimer l'étape" ou presser la touche "d" pour supprimer tous les points (et toutes les sections) de l'étape. Cette action fait également passer en mode supervision.</li>
<li>Cliquer sur le bouton "Quitter édition de l'étape" ou presser la touche "Echappement" pour terminer la création/modification de l'étape et passer en mode supervision.</li>
<li>Cliquer sur le bouton "Démarrer création nouvelle étape" ou double-cliquer sur la carte pour terminer la création/modification de l'étape en cours et passer en mode création/modification d'une nouvelle étape.</li>
<li>Double-cliquer sur un point ou une section d'une autre étape pour terminer la création/modification de l'étape en cours et passer en mode édition/modification pour l'autre étape.</li>
<li>Cliquer sur le boutton "Importer étapes de GPX" ou presser la touche "i" pour importer de nouvelles étapes à partir d'un fichier GPX. Ces étapes s'ajoutent à celles qui figurent déjà dans l'application.</li>
<li>Cliquer sur le bouton "Exporter l'itinéraire vers GPX" ou presser la touche "e" pour exporter l'itinéraire en cours dans un fichier GPX.</li>
<li>Cliquer sur le bouton "Réinitialiser l'itinéraire" ou presser la touche "z" pour réinitialiser l'itinéraire (c'est-à-dire en supprimer toutes les étapes).</li>
</ul>
<h3>Mode supervision</h3>
<p>Ce mode permet de visualiser les étapes de l'itinéraire sans qu'aucune ne soit en cours de création/modification. Les points de départ et d'arrivée de chaque étape sont représentés, mais pas les points de passage.</p> 
<p>Les actions disponibles sont :</p>
<ul>
<li>Cliquer sur le bouton "Démarrer création nouvelle étape" ou double-cliquer sur la carte pour terminer la création/modification de l'étape en cours et passer en mode création/modification d'une nouvelle étape.</li>
<li>Double-cliquer sur un point ou une section d'une autre étape pour terminer la création/modification de l'étape en cours et passer en mode édition/modification pour l'autre étape.</li>
<li>Cliquer sur le boutton "Importer étapes de GPX" ou presser la touche "i" pour importer de nouvelles étapes à partir d'un fichier GPX. Ces étapes s'ajoutent à celles qui figurent déjà dans l'application.</li>
<li>Cliquer sur le bouton "Exporter l'itinéraire vers GPX" ou presser la touche "e" pour exporter l'itinéraire en cours dans un fichier GPX.</li>
<li>Cliquer sur le bouton "Réinitialiser l'itinéraire" ou presser la touche "z" pour réinitialiser l'itinéraire (c'est-à-dire en supprimer toutes les étapes).</li>
</ul>
<h2>Divers</h2>
<p>La langue de l'interface utilisateur peut être choisie : anglais (par défaut) ou français.</p>
<p>Les unités de mesure peuvent être choisies à l'aide des boutons radio "Unités de mesure" : métriques (par default) ou impériales.</p>
<p>Des informations telles que le nom de l'étape, sa longueur, les altitudes de départ et d'arrivée, les dénivelés positif et négatif peuvent être affichées ou masquées.</p>
<p>Une fonction de géolocalisation est fournie (en haut à gauche). Elle permet de déterminer la position de l'utilisateur et de centrer la carte dessus. L'API de géolocalisation du navigateur est utilisée pour cela.</p>
<p>Une fonction de recherche de lieu à partir d'une adresse est fournie (en haut à gauche). Elle permet de rechercher un lieu à partir d'une adresse plus ou moins détaillée et de centrer la carte dessus. Plusieurs lieux correspondant à la recherche peuvent être trouvés et affichés sous forme de liste. Le service de géocodage Nominatim est utilisé pour cela.</p>
        `);
    }
    </script>
</body>
</html>

